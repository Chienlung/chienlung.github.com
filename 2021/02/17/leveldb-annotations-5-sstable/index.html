<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"chienlungcheung.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="[toc]    1 sstable 文件布局 1.1 data block 布局 1.2 meta block 布局 1.3 meta-index block 布局 1.4 index block 布局 1.5 footer 布局   2 sorted string table 文件主要接口 2.1 sorted string table 文件读接口 2.1.1 Block 结构 2.1.2 构">
<meta property="og:type" content="article">
<meta property="og:title" content="Leveldb 源码详解系列之五: SSTable 设计与实现">
<meta property="og:url" content="https://chienlungcheung.github.io/2021/02/17/leveldb-annotations-5-sstable/index.html">
<meta property="og:site_name" content="programatrix">
<meta property="og:description" content="[toc]    1 sstable 文件布局 1.1 data block 布局 1.2 meta block 布局 1.3 meta-index block 布局 1.4 index block 布局 1.5 footer 布局   2 sorted string table 文件主要接口 2.1 sorted string table 文件读接口 2.1.1 Block 结构 2.1.2 构">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-02-17T10:55:21.000Z">
<meta property="article:modified_time" content="2021-05-28T09:20:45.704Z">
<meta property="article:author" content="Chienlung Cheung">
<meta property="article:tag" content="leveldb">
<meta property="article:tag" content="LSM-Tree">
<meta property="article:tag" content="db">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://chienlungcheung.github.io/2021/02/17/leveldb-annotations-5-sstable/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Leveldb 源码详解系列之五: SSTable 设计与实现 | programatrix</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-177829579-1"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-177829579-1');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">programatrix</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Be the change you wish to see in the world.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://chienlungcheung.github.io/2021/02/17/leveldb-annotations-5-sstable/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chienlung Cheung">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="programatrix">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Leveldb 源码详解系列之五: SSTable 设计与实现
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-02-17 10:55:21" itemprop="dateCreated datePublished" datetime="2021-02-17T10:55:21+00:00">2021-02-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-05-28 09:20:45" itemprop="dateModified" datetime="2021-05-28T09:20:45+00:00">2021-05-28</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2021/02/17/leveldb-annotations-5-sstable/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2021/02/17/leveldb-annotations-5-sstable/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>[toc]</p>
<!-- toc -->

<ul>
<li><a href="#1-sstable-%E6%96%87%E4%BB%B6%E5%B8%83%E5%B1%80">1 sstable 文件布局</a><ul>
<li><a href="#11-data-block-%E5%B8%83%E5%B1%80">1.1 data block 布局</a></li>
<li><a href="#12-meta-block-%E5%B8%83%E5%B1%80">1.2 meta block 布局</a></li>
<li><a href="#13-meta-index-block-%E5%B8%83%E5%B1%80">1.3 meta-index block 布局</a></li>
<li><a href="#14-index-block-%E5%B8%83%E5%B1%80">1.4 index block 布局</a></li>
<li><a href="#15-footer-%E5%B8%83%E5%B1%80">1.5 footer 布局</a></li>
</ul>
</li>
<li><a href="#2-sorted-string-table-%E6%96%87%E4%BB%B6%E4%B8%BB%E8%A6%81%E6%8E%A5%E5%8F%A3">2 sorted string table 文件主要接口</a><ul>
<li><a href="#21-sorted-string-table-%E6%96%87%E4%BB%B6%E8%AF%BB%E6%8E%A5%E5%8F%A3">2.1 sorted string table 文件读接口</a><ul>
<li><a href="#211-block-%E7%BB%93%E6%9E%84">2.1.1 Block 结构</a></li>
<li><a href="#212-%E6%9E%84%E9%80%A0%E8%BF%AD%E4%BB%A3%E5%99%A8">2.1.2 构造迭代器</a></li>
</ul>
</li>
<li><a href="#22-sorted-string-table-%E6%96%87%E4%BB%B6%E5%86%99%E6%8E%A5%E5%8F%A3">2.2 sorted string table 文件写接口</a><ul>
<li><a href="#221-%E6%80%BB%E5%B9%B2%E4%BA%8B-tablebuilder">2.2.1 总干事 TableBuilder</a><ul>
<li><a href="#2211-tablebuilder-%E7%9A%84%E5%AD%98%E5%82%A8%E5%B0%8F%E5%8A%A9%E6%89%8B-rep">2.2.1.1 TableBuilder 的存储小助手 Rep</a></li>
</ul>
</li>
<li><a href="#222-%E5%86%99-data-blocks">2.2.2 写 data blocks</a></li>
<li><a href="#223-%E5%86%99-metafilter-block">2.2.3 写 meta(filter) block</a></li>
<li><a href="#224-%E5%86%99-meta-index-block">2.2.4 写 meta-index block</a></li>
<li><a href="#225-%E5%86%99-data-index-block">2.2.5 写 data-index block</a></li>
<li><a href="#226-%E5%86%99-footer">2.2.6 写 footer</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

<p>leveldb, leveldb, 每个 level 保存的内容就是一组 sorted string table (简称 sstable) 文件.</p>
<h1><span id="1-sstable-文件布局">1 sstable 文件布局</span></h1><p>SSTable 即 sorted string table, 是一个有序文件格式.</p>
<p>该文件主要包含五个部分:</p>
<ul>
<li>一系列 data blocks, 这里保存的我们需要的数据.</li>
<li>一系列 meta blocks, 这里目前保存的只有布隆过滤器. 通过它, 在不解析 data blocks 的前提下就能知道某个 key 是否存在, 如果可能存在也能快速缩小到可能在哪个 data block.</li>
<li>一个 metaindex block, 包含指向 meta blocks 的索引.</li>
<li>一个 index block, 包含指向 data blocks 的索引. </li>
<li>一个 footer, sstable 文件入口, 保存着指向 metaindex block 和 index block 的索引, 相当于一个二级指针.</li>
</ul>
<p>不像 kafka 文件存储结构的数据文件和索引文件是各自独立的(在查询时根据具体 key 先在索引文件确定是哪个数据文件), sstable 把索引和数据保存到了同一个文件中. 每次从文件查询数据时会先查询索引, 索引是指向数据的指针, 具体叫做 BlockHandle, 包含着下述信息: </p>
<pre><code>// 目标 block 起始位置在文件中的偏移量
offset: varint64
// 目标 block 的大小
size:   varint64</code></pre>
<p>形象地说, sstable 文件具体布局如下: </p>
<pre><code>&lt;beginning_of_file&gt;
[data block 1]
[data block 2]
...
[data block N]
[meta block 1]
...
[meta block K]
[metaindex block]
[index block]
[Footer]        (fixed size; starts at file_size - sizeof(Footer))
&lt;end_of_file&gt;</code></pre>
<p>下面具体讲一下每个段的具体布局.</p>
<h2><span id="11-data-block-布局">1.1 data block 布局</span></h2><p>每个 block 包含的数据笼统地讲, 包含 <code>&lt;一系列数据项 + restart array + restart number&gt;</code> “. </p>
<p>为了节省存储空间, block 中的数据项的 key 使用了前缀压缩. 具体来说, 存储某个 key 的时候先计算它和前一个数据项 key 的公共前缀长度, 公共前缀不再重复存储而是仅记录一个长度(shared), 由于 block 保存的数据是按 key 有序的, 排在一起的前缀都是比较相近的, 而且相似前缀可能还比较长所以该策略可以大幅节省存储空间.</p>
<p>block 中有一个至关重要的概念, 叫 <strong>restart point</strong>. 这个概念和前面提到的前缀压缩密切相关, 每个 block 的前缀压缩不是从第一个数据项开始就一直下去, 而是每隔一段(间隔可配置)设置一个新的前缀压缩起点(作为新起点的数据项的 key 保存原值而非做前缀压缩), restart point 指的就是新起点, 从这个地方开始继续做前缀压缩.</p>
<p>block 中每个数据项的格式如下: </p>
<ul>
<li>shared_bytes: varint32(与前一个 key 公共前缀的长度). 注意, 如果该数据项位于 restart 处, 则 shared_bytes 等于 0.</li>
<li>unshared_bytes: varint32(当前 key 除去公共前缀后的长度)</li>
<li>value_length: varint32(当前 key 对应的 value 的长度)</li>
<li>key_delta: char[unshared_bytes](当前 key 除去共享前缀后的字节内容)</li>
<li>value: char[value_length](当前 key 对应的 value 的数据内容)</li>
</ul>
<p>block 结尾处有个 trailer, 格式如下: </p>
<ul>
<li>restarts: uint32[num_restarts](保存 restart points 在 block 内偏移量的数组)</li>
<li>num_restarts: uint32(restart points 偏移量数组大小)<br>restarts[i] 保存的是第 i 个 restart point 在 block 内的偏移量.</li>
</ul>
<h2><span id="12-meta-block-布局">1.2 meta block 布局</span></h2><h2><span id="13-meta-index-block-布局">1.3 meta-index block 布局</span></h2><h2><span id="14-index-block-布局">1.4 index block 布局</span></h2><h2><span id="15-footer-布局">1.5 footer 布局</span></h2><p>Footer 虽然位于 sstable 文件尾部, 但它是名副其实的文件入口, 它的<strong>长度固定</strong>, 很容易从文件尾定位到, 它包含:</p>
<ul>
<li>一个指向 metaindex block 的 BlockHandle </li>
<li>一个指向 index block 的 BlockHandle </li>
<li>一个 magic number. </li>
</ul>
<p>Footer 具体格式如下:</p>
<pre><code>// 指向 metaindex block 的 BlockHandle
metaindex_handle: char[p];     
// 指向 index block 的 BlockHandle
index_handle:     char[q];     
// 用于维持固定长度的 padding 0,
// (其中 40 == 2*BlockHandle::kMaxEncodedLength)
padding:          char[40-p-q];
// 具体内容为 0xdb4775248b80fb57 (小端字节序)
magic:            fixed64;     </code></pre>
<p>注意 footer 存的都是 <em>index-of-xx</em>, 找到 <em>index</em> 就可以找到 <em>xx</em> 了.</p>
<p>关于 sstable 的其它细节请见 <a href="/2020/09/11/leveldb-annotations-1-interfaces-and-files/" title="Leveldb 源码详解系列之一: 接口与文件">Leveldb 源码详解系列之一: 接口与文件</a>. </p>
<p>了解了布局, 下面让我们来看看针对 sstable 的读写实现.</p>
<h1><span id="2-sorted-string-table-文件主要接口">2 sorted string table 文件主要接口</span></h1><p>下面说明一下 sorted string table 文件主要的操作接口, 主要是读与写.</p>
<h2><span id="21-sorted-string-table-文件读接口">2.1 sorted string table 文件读接口</span></h2><p>打开一个 sstable 文件的入口为 <code>leveldb::Status leveldb::Table::Open</code>. 最后得到一个 <code>class leveldb::Table</code> 对象, 该类是对 sorted string table 文件的抽象, 负责对 sorted string table 文件进行读操作. 具体底层存储由 Table 的 helper 类 <code>struct leveldb::Table::Rep</code> 负责. 代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 file 表示的 sstable 文件反序列化为 Table 对象, 具体保存</span></span><br><span class="line"><span class="comment">// 实际内容的是 Table::rep_.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 如果成功, 返回 OK 并将 *table 设置为新打开的 table. </span></span><br><span class="line"><span class="comment">// 当不再使用该 table 时候, 需要调用方负责删除之. </span></span><br><span class="line"><span class="comment">// 如果初始化 table 出错, 将 *table 设置为 nullptr 并返回 non-OK. </span></span><br><span class="line"><span class="comment">// 注意, 在 table 打开期间, 调用方要确保数据源即 file 持续有效. </span></span><br><span class="line"><span class="function">Status <span class="title">Table::Open</span><span class="params">(<span class="keyword">const</span> Options&amp; options,</span></span></span><br><span class="line"><span class="function"><span class="params">                   RandomAccessFile* file,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">uint64_t</span> size,</span></span></span><br><span class="line"><span class="function"><span class="params">                   Table** table)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 1 先解析 table 文件结尾的 Footer, 它是 sstable 的入口.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  *table = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="comment">// 每个 table 文件末尾是一个固定长度的 footer</span></span><br><span class="line">  <span class="keyword">if</span> (size &lt; Footer::kEncodedLength) &#123; </span><br><span class="line">    <span class="keyword">return</span> Status::Corruption(<span class="string">&quot;file is too short to be an sstable&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> footer_space[Footer::kEncodedLength];</span><br><span class="line">  Slice footer_input;</span><br><span class="line">  <span class="comment">// 读取 footer, 放到 footer_input</span></span><br><span class="line">  Status s = file-&gt;Read(size - Footer::kEncodedLength, Footer::kEncodedLength,</span><br><span class="line">                        &amp;footer_input, footer_space);</span><br><span class="line">  <span class="keyword">if</span> (!s.ok()) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">  Footer footer;</span><br><span class="line">  <span class="comment">// 解析 footer</span></span><br><span class="line">  s = footer.DecodeFrom(&amp;footer_input);</span><br><span class="line">  <span class="keyword">if</span> (!s.ok()) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 2 根据已解析的 Footer, 解析出 index block(它保存了指向全部 data blocks 的索引) </span></span><br><span class="line"><span class="comment">   * 存储到 index_block_contents.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  BlockContents index_block_contents;</span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    ReadOptions opt;</span><br><span class="line">    <span class="keyword">if</span> (options.paranoid_checks) &#123;</span><br><span class="line">      opt.verify_checksums = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取 index block, 它对应的 BlockHandle 存储在 footer 里面</span></span><br><span class="line">    s = ReadBlock(file, opt, footer.index_handle(), &amp;index_block_contents);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    <span class="comment">// 已经成功读取了 Footer 和 index block, 是时候读取 data 了. </span></span><br><span class="line">    Block* index_block = <span class="keyword">new</span> Block(index_block_contents);</span><br><span class="line">    Rep* rep = <span class="keyword">new</span> Table::Rep;</span><br><span class="line">    rep-&gt;options = options;</span><br><span class="line">    rep-&gt;file = file;</span><br><span class="line">    <span class="comment">// filter-index block 对应的指针 (二级索引), 解析 footer 时候就拿到了.</span></span><br><span class="line">    rep-&gt;metaindex_handle = footer.metaindex_handle();</span><br><span class="line">    <span class="comment">// data-index block </span></span><br><span class="line">    <span class="comment">// (注意它只是一个索引, 即 data blocks 的索引, </span></span><br><span class="line">    <span class="comment">//  真正使用的时候是基于 data-index block 做二级迭代器来进行查询,</span></span><br><span class="line">    <span class="comment">//  一级索引跨度大, 二级索引粒度小, 可以快速定位数据,</span></span><br><span class="line">    <span class="comment">//  具体见 Table::NewIterator() 方法)</span></span><br><span class="line">    rep-&gt;index_block = index_block;</span><br><span class="line">    <span class="comment">// 如果调用方要求缓存这个 table, 则为其分配缓存 id</span></span><br><span class="line">    rep-&gt;cache_id = (options.block_cache ? options.block_cache-&gt;NewId() : <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 接下来跟 filter 相关的两个成员将在下面 ReadMeta 进行填充.</span></span><br><span class="line">    rep-&gt;filter_data = <span class="literal">nullptr</span>;</span><br><span class="line">    rep-&gt;filter = <span class="literal">nullptr</span>;</span><br><span class="line">    *table = <span class="keyword">new</span> Table(rep);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3 根据已解析的 Footer 所包含的 metaindex block 指针, </span></span><br><span class="line"><span class="comment">     * 解析出 metaindex block, 再基于此解析出 mate block </span></span><br><span class="line"><span class="comment">     * 存储到 Table::rep_.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 读取并解析 filter block 到 table::rep_, </span></span><br><span class="line">    <span class="comment">// 它一般为布隆过滤器, 可以加速数据查询过程.</span></span><br><span class="line">    (*table)-&gt;ReadMeta(footer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结下, 该方法主要干了下面三件事:</p>
<ol>
<li>先解析 sstable 文件结尾的 Footer, 它是 sstable 的入口.</li>
<li>根据已解析的 Footer, 解析出 (data) index block 存储到 Table::rep_.</li>
<li>根据已解析的 Footer, 解析出 meta block 存储到 Table::rep_.</li>
</ol>
<p>注意, <code>Open</code> 方法并未去解析 data block 部分, 仅仅是解析了它对应的 index block 部分; 但是解析出了 meta block, 因为它包含的是过滤器, 用来快速确认 key 是否存在.</p>
<p><code>Open()</code> 方法会读取 block 构造 Block 然后到 Table::Rep 中, 下面我们讲一下 Block 结构.</p>
<h3><span id="211-block-结构">2.1.1 Block 结构</span></h3><p>Block 定义在 <code>table/block.h</code> 和 <code>table/block.cc</code> 文件, 它主要用于将 sstable 反序列化后盛放 block 内容.   </p>
<p>具体类定义如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Block</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 使用特定的 contents 来构造一个 Block</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Block</span><span class="params">(<span class="keyword">const</span> BlockContents&amp; contents)</span></span>;</span><br><span class="line"></span><br><span class="line">  ~Block();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> size_; &#125;</span><br><span class="line">  <span class="comment">// 根据用户定制的 comparator 构造该 block 的一个迭代器</span></span><br><span class="line">  <span class="function">Iterator* <span class="title">NewIterator</span><span class="params">(<span class="keyword">const</span> Comparator* comparator)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">uint32_t</span> <span class="title">NumRestarts</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// block 全部数据(数据项 + restart array + restart number)</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* data_;</span><br><span class="line">  <span class="comment">// block 总大小 </span></span><br><span class="line">  <span class="keyword">size_t</span> size_; </span><br><span class="line">  <span class="comment">// block 的 restart array 在 block 中的起始偏移量</span></span><br><span class="line">  <span class="keyword">uint32_t</span> restart_offset_;</span><br><span class="line">  <span class="comment">// 如果 data_ 指向的空间是在堆上分配的, </span></span><br><span class="line">  <span class="comment">// 那么该 block 对象销毁时需要释放该处空间, 该成员使用见析构方法.</span></span><br><span class="line">  <span class="keyword">bool</span> owned_;                  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不允许拷贝 block </span></span><br><span class="line">  Block(<span class="keyword">const</span> Block&amp;);</span><br><span class="line">  <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> Block&amp;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为迭代 block 内容服务的迭代器, block 相当于迭代器的数据源.</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Iter</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>构造 Block 只有一种方式, 就是先读取文件内容构造 BlockContents, 然后基于 BlockContents 构造 Block, 这个调用是 <code>Table::Open()</code> 负责的: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Block::Block(<span class="keyword">const</span> BlockContents&amp; contents)</span><br><span class="line">    : data_(contents.data.data()),</span><br><span class="line">      size_(contents.data.size()),</span><br><span class="line">      owned_(contents.heap_allocated) &#123; </span><br><span class="line">  <span class="comment">//　当数据存储在堆上的时候 owned_ 才为 true</span></span><br><span class="line">  <span class="keyword">if</span> (size_ &lt; <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>)) &#123; </span><br><span class="line">    <span class="comment">// block 最后 4 字节用于存储 restart 个数, 所以最小也为 4 字节长度</span></span><br><span class="line">    size_ = <span class="number">0</span>;  <span class="comment">// Error marker</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 该 Block 最多可以分配的 restart 的个数, 其中每个 restart </span></span><br><span class="line">    <span class="comment">// 为 4 字节偏移量.</span></span><br><span class="line">    <span class="comment">// 在构建 block 的时候会每隔一段设置一个 restart point, </span></span><br><span class="line">    <span class="comment">// 位于 restart point 的数据项的 key 不会进行前缀压缩, 此项之后</span></span><br><span class="line">    <span class="comment">// 的数据项会相对于前一个数据项进行前缀压缩直至下一个 restart  point. </span></span><br><span class="line">    <span class="comment">// block 最后 4 字节用于存储 restart 个数, 所以计算时不能算在内. </span></span><br><span class="line">    <span class="keyword">size_t</span> max_restarts_allowed = (size_-<span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>)) / <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">    <span class="keyword">if</span> (NumRestarts() &gt; max_restarts_allowed) &#123;</span><br><span class="line">      <span class="comment">// 如果实际的 restart 总数超过了上面计算的最大值, </span></span><br><span class="line">      <span class="comment">// 那该 Block 空间太小了, 肯定有问题</span></span><br><span class="line">      size_ = <span class="number">0</span>; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 最后一个 uint_32 存的是 restart 个数, 不能用于存放 restart; </span></span><br><span class="line">      <span class="comment">// 全部 restart 占用字节数为 NumRestarts() * sizeof(uint32_t); </span></span><br><span class="line">      <span class="comment">// 所以 restart array 的起始 offset 为下面的值. </span></span><br><span class="line">      restart_offset_ = size_ - (<span class="number">1</span> + NumRestarts()) * <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="212-构造迭代器">2.1.2 构造迭代器</span></h3><p>从外部 (这里强调外部, 是因为还有一个私有方法 <code>leveldb::Status leveldb::Table::InternalGet</code> 可以访问 Table 对象内容) 打开文件后如果要访问其内容, 需要一个迭代器, 该工作通过 <code>leveldb::Iterator *leveldb::Table::NewIterator</code> 完成. 返回的迭代器为一个 <code>leveldb::&lt;unnamed&gt;::TwoLevelIterator</code>, 该迭代器处于匿名的命名空间所以未直接对外暴露, 仅能通过返回的指针访问其从 <code>class leveldb::Iterator</code> 继承的方法. 该迭代器设计精巧, 会单独写文章介绍.</p>
<h2><span id="22-sorted-string-table-文件写接口">2.2 sorted string table 文件写接口</span></h2><p>完成该工作的是 <code>class leveldb::TableBuilder</code>, 该类负责构造 sstable 文件. </p>
<p>具体构造和写入顺序为:</p>
<ul>
<li>写 data blocks</li>
<li>写 meta blocks(目前仅有过滤器)</li>
<li>写 meta-index block</li>
<li>写 data-index block</li>
<li>写 footer</li>
</ul>
<p>每个分段也都有类似 XXBuilder 的类, 具体构造时会被 TableBuilder 调用. 除此之外, 还有一个类似的地方, 就是每个 XXBuilder 主要干活的基本都叫做 <code>Add()</code> 和 <code>Finish()</code> , 前者负责将具体数据添加到自己分段中, 后者负责将本段的元数据追加到自己分段尾部从而完成分段构造. 具体执行过程中, 各个 XXBuilder 有交叉的地方. 典型地, BlockBuilder 构造 data block 时会将自己的 BlockHandle 保存到 index block, 同时会将自己的 key 添加到 filter block 的相关状态里. 具体下面详述.</p>
<h3><span id="221-总干事-tablebuilder">2.2.1 总干事 TableBuilder</span></h3><p>该类是构造 sstable 的入口, 外部(如 <code>leveldb::BuildTable()</code> 方法在被 <code>leveldb::DBImpl::WriteLevel0Table()</code> 方法调用将 memtable 转为 sstable 的时候)直接循环调用该类的 <code>Add()</code> 方法来向 sstable 追加 k,v 数据, 追加完毕后调用该类 <code>Finish()</code> 方法做收尾工作.</p>
<p>下面列出 TableBuilder 比较核心的成员:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该类用于构造 sstable(sorted string table) 文件. </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 如果用户从多个线程调用该类的 const 方法, 线程安全; </span></span><br><span class="line"><span class="comment">// 如果从多个线程调用非 const 方法, 则需要依赖外部同步设施确保线程安全. </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LEVELDB_EXPORT</span> <span class="title">TableBuilder</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 将一对 &lt;key,value&gt; 追加到正在构造的 table 中. </span></span><br><span class="line">  <span class="comment">// 要求 1: key 必须大于任何之前已经添加过的 keys, </span></span><br><span class="line">  <span class="comment">//        因为该文件是有序的.</span></span><br><span class="line">  <span class="comment">// 要求 2: 还没调用过 Finish() 或者 Abandon(), </span></span><br><span class="line">  <span class="comment">//        调用了这两个方法表示 table 对应文件被关掉了.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; value)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 该方法由 Add() 和 Finish() 调用, 将缓冲的 data block 写入文件.</span></span><br><span class="line">  <span class="comment">// 要求: 还没调用过 Finish() 或者 Abandon(). </span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Flush</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 完成 table 构建. 该方法返回后停止使用在构造方法中传入的文件. </span></span><br><span class="line">  <span class="comment">// 要求: 还没调用过 Finish() 或者 Abandon(). </span></span><br><span class="line">  <span class="comment">// table 构成: data blocks, filter block, metaindex block, index block</span></span><br><span class="line">  <span class="function">Status <span class="title">Finish</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 将 data block 内容根据设置进行压缩, 然后写入文件;</span></span><br><span class="line">  <span class="comment">// 同时将 data block 在 table 偏移量和 size 设置到</span></span><br><span class="line">  <span class="comment">// handle 中, 写完 block 会将其 handle 写入</span></span><br><span class="line">  <span class="comment">// index block.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">WriteBlock</span><span class="params">(BlockBuilder* block, BlockHandle* handle)</span></span>;</span><br><span class="line">  <span class="comment">// 将 block 及其 trailer(注意这个 trailer 不是 block 内部的 trailer)</span></span><br><span class="line">  <span class="comment">// 写入 table 对应的文件, </span></span><br><span class="line">  <span class="comment">// 并将 block 对应的 BlockHandle 内容保存到 handle 中. </span></span><br><span class="line">  <span class="comment">// 写失败时该方法只将错误状态记录到 r-&gt;status, 不做其它任何处理.</span></span><br><span class="line">  <span class="comment">// 该方法由 WriteBlock 调用.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">WriteRawBlock</span><span class="params">(<span class="keyword">const</span> Slice&amp; data, CompressionType, BlockHandle* handle)</span></span>;</span><br><span class="line">  <span class="comment">// 这个结构体很重要, 是 Table 实际存储数据的结构体, 下面单独开辟一节讲述.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Rep</span>;</span></span><br><span class="line">  <span class="comment">// 存储构造过程中的 table</span></span><br><span class="line">  Rep* rep_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>主要方法有以下两个:</p>
<ul>
<li><code>void BlockBuilder::Add(const Slice&amp; key, const Slice&amp; value)</code> 负责向 TableBuilder 对象添加 (key, value), 该工作主要由 <code>class leveldb::BlockBuilder::Add()</code> 方法完成.</li>
<li><code>void leveldb::TableBuilder::Finish()</code> 负责将整个 Table 序列化为一个 sstable 文件并写入磁盘.</li>
</ul>
<p><code>Add()</code> 方法在构造 data block 和 index block 时用到了 <code>BlockBuilder</code> 对应方法, <code>Add()</code> 实现如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将一对 &lt;key,value&gt; 追加到正在构造的 table 中.</span></span><br><span class="line"><span class="comment">// 该方法追加数据时会同时影响到 data block, data index block, </span></span><br><span class="line"><span class="comment">// meta block 的构造.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TableBuilder::Add</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; value)</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  <span class="comment">// 确保之前没有调用过 Finish() 或者 Abandon()</span></span><br><span class="line">  assert(!r-&gt;closed); </span><br><span class="line">  <span class="keyword">if</span> (!ok()) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 如果该条件成立则说明之前调用过 Add 添加过数据了</span></span><br><span class="line">  <span class="keyword">if</span> (r-&gt;num_entries &gt; <span class="number">0</span>) &#123; </span><br><span class="line">    <span class="comment">// 确保待添加的 key 大于之前已添加过的全部 keys</span></span><br><span class="line">    assert(r-&gt;options.comparator-&gt;Compare(key, Slice(r-&gt;last_key)) &gt; <span class="number">0</span>); </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 需要构造一个新的 data block</span></span><br><span class="line">  <span class="keyword">if</span> (r-&gt;pending_index_entry) &#123;</span><br><span class="line">    <span class="comment">// 与上面紧邻的这个判断条件构成不变式, 为空表示</span></span><br><span class="line">    <span class="comment">// 已经将写满的 data block flush 到文件了.</span></span><br><span class="line">    assert(r-&gt;data_block.empty());</span><br><span class="line">    <span class="comment">// 为 pending index entry 选一个合适的 key.</span></span><br><span class="line">    <span class="comment">// 下面这个函数调用结束, last_key 可能不变, 也可能长度更短但是值更大, </span></span><br><span class="line">    <span class="comment">// 但不会 &gt;= 要追加的 key. 因为进入该方法之前关于两个参数</span></span><br><span class="line">    <span class="comment">// 已经有了一个约束: 第一个字符串肯定小于第二个字符串, 这个上面有断言保证了.</span></span><br><span class="line">    r-&gt;options.comparator-&gt;FindShortestSeparator(&amp;r-&gt;last_key, key);</span><br><span class="line">    <span class="comment">// 用于存储序列化后的 BlockHandle</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> handle_encoding;</span><br><span class="line">    <span class="comment">// 将刚刚 flush 过的 data block 对应的 BlockHandle 序列化</span></span><br><span class="line">    r-&gt;pending_handle.EncodeTo(&amp;handle_encoding);</span><br><span class="line">    <span class="comment">// data index block 构造相关:</span></span><br><span class="line">    <span class="comment">// 为刚刚 flush 过的 data block 在 index block 增加一个数据项, </span></span><br><span class="line">    <span class="comment">// last_key 肯定大于等于其全部所有的 keys 且小于新的 </span></span><br><span class="line">    <span class="comment">// data block 的第一个 key.</span></span><br><span class="line">    r-&gt;index_block.Add(r-&gt;last_key, Slice(handle_encoding));</span><br><span class="line">    <span class="comment">// 增加过 index entry 后, 可以将其置为 false 了.</span></span><br><span class="line">    r-&gt;pending_index_entry = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// meta block 构造相关:</span></span><br><span class="line">  <span class="comment">// 如果该 table 存在 filter block, 则将该 key 加入.</span></span><br><span class="line">  <span class="comment">// (filter block 可以用于快速定位 key 是否存在于 table 中).</span></span><br><span class="line">  <span class="comment">// 加入的 key 在 FilterBlockBuilder 中使用.</span></span><br><span class="line">  <span class="keyword">if</span> (r-&gt;filter_block != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    r-&gt;filter_block-&gt;AddKey(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用新 key 更新 last_key</span></span><br><span class="line">  r-&gt;last_key.assign(key.data(), key.size());</span><br><span class="line">  r-&gt;num_entries++;</span><br><span class="line">  <span class="comment">// data block 相关:</span></span><br><span class="line">  <span class="comment">// 将 key,value 添加到 data block 中</span></span><br><span class="line">  r-&gt;data_block.Add(key, value); </span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> estimated_block_size = r-&gt;data_block.CurrentSizeEstimate();</span><br><span class="line">  <span class="comment">// 如果当前 data block 大小的估计值大于设定的阈值, </span></span><br><span class="line">  <span class="comment">// 则将该 data block 写入文件</span></span><br><span class="line">  <span class="keyword">if</span> (estimated_block_size &gt;= r-&gt;options.block_size) &#123;</span><br><span class="line">    Flush();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Add()</code> 在检测到 data block 大小达到阈值时会调用 <code>Flush()</code> 将数据刷入文件. 刷入完成, 会调用 FilterBlockBuilder 为其生成 filter. 具体如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add() 依赖 Flush() 将大小满足要求的 block 写入文件中.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TableBuilder::Flush</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  assert(!r-&gt;closed);</span><br><span class="line">  <span class="keyword">if</span> (!ok()) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;data_block.empty()) <span class="keyword">return</span>;</span><br><span class="line">  assert(!r-&gt;pending_index_entry);</span><br><span class="line">  <span class="comment">// 将 data block 压缩并落盘, 在该方法中 data_block 会调用 Reset()</span></span><br><span class="line">  WriteBlock(&amp;r-&gt;data_block, &amp;r-&gt;pending_handle); </span><br><span class="line">  <span class="keyword">if</span> (ok()) &#123;</span><br><span class="line">    <span class="comment">// flush 一个 data block, 就要在 index block 为其增加一个指针.</span></span><br><span class="line">    r-&gt;pending_index_entry = <span class="literal">true</span>;</span><br><span class="line">    r-&gt;status = r-&gt;file-&gt;Flush();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;filter_block != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 为已经刷入文件的 data block 计算 filter, 同时</span></span><br><span class="line">    <span class="comment">// 为新的 data block 计算 filter 做准备, </span></span><br><span class="line">    <span class="comment">// r-&gt;offset 为下个 block 在 table 的起始地址, </span></span><br><span class="line">    <span class="comment">// 该值在上面 WriteBlock 调用 WriteRawBlock 时会进行更新.</span></span><br><span class="line">    r-&gt;filter_block-&gt;StartBlock(r-&gt;offset); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="2211-tablebuilder-的存储小助手-rep">2.2.1.1 TableBuilder 的存储小助手 Rep</span></h4><p>从 TableBuilder 定义可以看到, private 部分有一个 Rep, 这是 TableBuilder 用于存放构造中的 sstable 的地方. 因为它太重要, 所以单独拿出来说一下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TableBuilder</span>:</span>:Rep &#123;</span><br><span class="line">  Options options;</span><br><span class="line">  Options index_block_options;</span><br><span class="line">  <span class="comment">// table 对应的文件指针</span></span><br><span class="line">  WritableFile* file; </span><br><span class="line">  <span class="comment">// table 文件当前的最大偏移量</span></span><br><span class="line">  <span class="keyword">uint64_t</span> offset; </span><br><span class="line">  Status status;</span><br><span class="line">  <span class="comment">// 用于构造 data block</span></span><br><span class="line">  BlockBuilder data_block; </span><br><span class="line">  <span class="comment">// 用于构造 data index block</span></span><br><span class="line">  BlockBuilder index_block; </span><br><span class="line">  <span class="comment">// 最近一次成功调用 Add 添加的 key</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> last_key; </span><br><span class="line">  <span class="comment">// 当前 table 中全部 data block entries 个数</span></span><br><span class="line">  <span class="keyword">int64_t</span> num_entries; </span><br><span class="line">  <span class="comment">// 指示是否调用过 Finish() 或 Abandon()</span></span><br><span class="line">  <span class="keyword">bool</span> closed;          </span><br><span class="line">  <span class="comment">// 用于构造 filter block</span></span><br><span class="line">  FilterBlockBuilder* filter_block; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 直到当追加下一个 data block 第一个 key 的时候, 我们才会将</span></span><br><span class="line">  <span class="comment">// 当前 data block 对应的 index 数据项追加到 index block,  </span></span><br><span class="line">  <span class="comment">// 这样可以让我们在 index block 使用更短的 key. </span></span><br><span class="line">  <span class="comment">// 举个例子, 假设当前 data block 最后一个</span></span><br><span class="line">  <span class="comment">// key &quot;the quick brown fox&quot;, 下一个 data block </span></span><br><span class="line">  <span class="comment">// 首个 key &quot;the who&quot; 之间, </span></span><br><span class="line">  <span class="comment">// 则我们可以为当前 data block 的 index 数据项设置</span></span><br><span class="line">  <span class="comment">// key &quot;the r&quot;, 因为它 &gt;= 当前 data block 全部 key, </span></span><br><span class="line">  <span class="comment">// 而且 &lt; 接下来 data block 的全部 key. </span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 不变式: 仅当 data_block 为空的时候(已经被 flush 过了)</span></span><br><span class="line">  <span class="comment">// r-&gt;pending_index_entry 才为 true. </span></span><br><span class="line">  <span class="comment">// 注意该变量初始值为 false, 也就是写满(大小可配置)并 flush 过一个</span></span><br><span class="line">  <span class="comment">// data block 时候才会写入它对应的 index entry, </span></span><br><span class="line">  <span class="comment">// 因为此时 index entry 才知道 data block 最大 key 是什么.</span></span><br><span class="line">  <span class="keyword">bool</span> pending_index_entry;</span><br><span class="line">  <span class="comment">// 与 pending_index_entry 配套, </span></span><br><span class="line">  <span class="comment">// 指向当前 data block 的 BlockHandle,</span></span><br><span class="line">  <span class="comment">// 会被追加到 index block 中.</span></span><br><span class="line">  BlockHandle pending_handle;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> compressed_output;</span><br><span class="line"></span><br><span class="line">  Rep(<span class="keyword">const</span> Options&amp; opt, WritableFile* f)</span><br><span class="line">      : options(opt),</span><br><span class="line">        index_block_options(opt),</span><br><span class="line">        file(f),</span><br><span class="line">        offset(<span class="number">0</span>),</span><br><span class="line">        data_block(&amp;options),</span><br><span class="line">        index_block(&amp;index_block_options),</span><br><span class="line">        num_entries(<span class="number">0</span>),</span><br><span class="line">        closed(<span class="literal">false</span>),</span><br><span class="line">        filter_block(opt.filter_policy == <span class="literal">nullptr</span> ? <span class="literal">nullptr</span></span><br><span class="line">                     : <span class="keyword">new</span> FilterBlockBuilder(opt.filter_policy)),</span><br><span class="line">        pending_index_entry(<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">// index block 的 key 不需要做前缀压缩, </span></span><br><span class="line">    <span class="comment">// 所以把该值设置为 1, 表示每个 restart 段长度为 1.</span></span><br><span class="line">    index_block_options.block_restart_interval = <span class="number">1</span>; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3><span id="222-写-data-blocks">2.2.2 写 data blocks</span></h3><p>BlockBuilder 被 TableBuilder 使用来构造 sstable 文件里的 block, 注意, 该类用于构造 block 的序列化形式, 也就是构造 sstable 时候使用; 反序列化用的是 Block 类.</p>
<p>要理解这里必须要清楚 block 布局, 这个在文章开头有详细描述. 建议回过头看一眼, 尤其 restart point 的设计. </p>
<p>同 TableBuilder 类似, BlockBuilder 最重要的两个方法也是 <code>Add()</code> 和 <code>Finish()</code>. TableBuilder 会重复使用 BlockBuilder 实例, 每写入一个 block 就会调用其 <code>Reset()</code> 将其恢复原状.</p>
<p>BlockBuilder 核心成员如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlockBuilder</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">BlockBuilder</span><span class="params">(<span class="keyword">const</span> Options* options)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重置 BlockBuilder 对象状态信息, 就像该对象刚刚被创建时一样. </span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Reset</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 与 Finish() 分工, 负责追加一个数据项到 buffer. </span></span><br><span class="line">  <span class="comment">// 前提: </span></span><br><span class="line">  <span class="comment">// 1. 自从上次调用 Reset() 还未调用过 Finish(); </span></span><br><span class="line">  <span class="comment">// 2. 参数 key 要大于任何之前已经添加过的数据项的 key,</span></span><br><span class="line">  <span class="comment">// 因为这是一个 append 类型操作. </span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; value)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 该方法负责 block 构建的收尾工作, 具体是将 restart points</span></span><br><span class="line">  <span class="comment">// 数组及其长度追加到 block 的数据内容之后完成构建工作, 最后返回</span></span><br><span class="line">  <span class="comment">// 一个指向 block 全部内容的 slice. </span></span><br><span class="line">  <span class="comment">// 返回的 slice 生命期同当前 builder, 若 builder 调用了</span></span><br><span class="line">  <span class="comment">// Reset() 方法则返回的 slice 失效. </span></span><br><span class="line">  <span class="function">Slice <span class="title">Finish</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 存储目标 block 内容的缓冲区</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span>           buffer_;</span><br><span class="line">  <span class="comment">// 存储目标 block 的全部 restart points</span></span><br><span class="line">  <span class="comment">// (即每个 restart point 在 block 中的偏移量, </span></span><br><span class="line">  <span class="comment">// 第一个 restart point 偏移量为 0)</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">uint32_t</span>&gt; restarts_;</span><br><span class="line">  <span class="comment">// 该 BlockBuilder 上次调用 Add 时追加的那个 key</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span>           last_key_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最重要的 <code>Add()</code> 和 <code>Finish()</code> 实现如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BlockBuilder::Add</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 上次调用 Add 追加的 key, 用于计算公共前缀</span></span><br><span class="line">  <span class="function">Slice <span class="title">last_key_piece</span><span class="params">(last_key_)</span></span>;</span><br><span class="line">  <span class="comment">// 不能往一个完成构建的 block 里追加数据.</span></span><br><span class="line">  assert(!finished_);</span><br><span class="line">  <span class="comment">// 自上个 restart 之后追加的 key 的个数没有超过要求的两个</span></span><br><span class="line">  <span class="comment">// restart points 之间 keys 的个数.</span></span><br><span class="line">  assert(counter_ &lt;= options_-&gt;block_restart_interval);</span><br><span class="line">  <span class="comment">// 当前要追加的 key 要大于任何之前追加到 buffer 中的 key</span></span><br><span class="line">  assert(buffer_.empty() <span class="comment">// No values yet?</span></span><br><span class="line">         || options_-&gt;comparator-&gt;Compare(key, last_key_piece) &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">size_t</span> shared = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 如果自上个 restart 之后追加的 key 的个数小于所配置的</span></span><br><span class="line">  <span class="comment">// 两个相邻 restart 之间 keys 的个数. </span></span><br><span class="line">  <span class="keyword">if</span> (counter_ &lt; options_-&gt;block_restart_interval) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> min_length = <span class="built_in">std</span>::min(last_key_piece.size(), key.size());</span><br><span class="line">    <span class="comment">// 计算当前要追加的 key 与上次追加的 key 的公共前缀长度. </span></span><br><span class="line">    <span class="keyword">while</span> ((shared &lt; min_length) &amp;&amp; (last_key_piece[shared] == key[shared])) &#123;</span><br><span class="line">      shared++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 否则, 新增一个 restart point, 而且作为 restart 的 key 不进行压缩. </span></span><br><span class="line">    <span class="comment">// - restart 就是一个 offset, 具体值为当前 buffer 所占空间大小. </span></span><br><span class="line">    <span class="comment">// - restart 后第一个数据项的 key 不进行压缩, 即不计算与前一个 key </span></span><br><span class="line">    <span class="comment">//   的公共前缀了, 而是把这个 key 整个保存起来, 但是本 &quot;restart&quot;  </span></span><br><span class="line">    <span class="comment">//   段, 从这个 key 开始后面的 keys 都要进行压缩.</span></span><br><span class="line">    restarts_.push_back(buffer_.size());</span><br><span class="line">    counter_ = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> non_shared = key.size() - shared;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add &quot;&lt;shared&gt;&lt;non_shared&gt;&lt;value_size&gt;&quot; to buffer_</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// buffer 里面的每个记录的格式为: </span></span><br><span class="line">  <span class="comment">// &lt;varint32 类型的当前 key 与上个 key 公共前缀长度&gt;</span></span><br><span class="line">  <span class="comment">// &lt;varint32 类型的当前 key 长度减去公共前缀后的长度&gt;</span></span><br><span class="line">  <span class="comment">// &lt;varint32 类型的当前 value 的长度&gt;</span></span><br><span class="line">  <span class="comment">// &lt;与前一个 key 公共前缀之后的部分&gt;</span></span><br><span class="line">  <span class="comment">// &lt;value&gt;</span></span><br><span class="line">  PutVarint32(&amp;buffer_, shared);</span><br><span class="line">  PutVarint32(&amp;buffer_, non_shared);</span><br><span class="line">  PutVarint32(&amp;buffer_, value.size());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 key 非公共部分和 value 追加到 buffer_</span></span><br><span class="line">  buffer_.append(key.data() + shared, non_shared);</span><br><span class="line">  buffer_.append(value.data(), value.size());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新状态</span></span><br><span class="line">  last_key_.resize(shared);</span><br><span class="line">  <span class="comment">// 将 last_key 更新为当前 key</span></span><br><span class="line">  last_key_.append(key.data() + shared, non_shared); </span><br><span class="line">  assert(Slice(last_key_) == key);</span><br><span class="line">  <span class="comment">// 将自上个 restart 之后的记录数加一</span></span><br><span class="line">  counter_++; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Slice <span class="title">BlockBuilder::Finish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 先将 restarts 数组编码后追加到 buffer, </span></span><br><span class="line"><span class="comment">   * 然后将 restarts 数组长度编码后追加到 buffer 并将 finished 置位, </span></span><br><span class="line"><span class="comment">   * 最后根据 buffer 构造一个新的 slice 返回(注意该 slice 引用的内存是 </span></span><br><span class="line"><span class="comment">   * buffer, 所以生命期同 builder, 除非 builder 调用了 Reset)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// Append restart array</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; restarts_.size(); i++) &#123;</span><br><span class="line">    PutFixed32(&amp;buffer_, restarts_[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  PutFixed32(&amp;buffer_, restarts_.size());</span><br><span class="line">  finished_ = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> Slice(buffer_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="223-写-metafilter-block">2.2.3 写 meta(filter) block</span></h3><p>不同于 data block 和 data index block, filter block 有专用的 builder, 叫做 <code>FilterBlockBuilder</code>. 它的核心方法是 <code>AddKey()</code> 和 <code>Finish()</code>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该类在其它地方定义. 用于定义过滤器逻辑.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilterPolicy</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// FilterBlockBuilder 用于构造 table 的全部 filters. </span></span><br><span class="line"><span class="comment">// 最后生成一个字符串保存在 Table 的一个 meta block 中. </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 该类的方法调用序列必须满足下面的正则表达式: </span></span><br><span class="line"><span class="comment">//      (StartBlock AddKey*)* Finish</span></span><br><span class="line"><span class="comment">// 最少调用一次 Finish, 而且 AddKey 和 Finish 之间不能插入 StartBlock 调用. </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilterBlockBuilder</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">FilterBlockBuilder</span><span class="params">(<span class="keyword">const</span> FilterPolicy*)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">StartBlock</span><span class="params">(<span class="keyword">uint64_t</span> block_offset)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">AddKey</span><span class="params">(<span class="keyword">const</span> Slice&amp; key)</span></span>;</span><br><span class="line">  <span class="function">Slice <span class="title">Finish</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">GenerateFilter</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> FilterPolicy* policy_;</span><br><span class="line">  <span class="comment">// 调用 AddKey() 时每个 key 都会被</span></span><br><span class="line">  <span class="comment">// 追加到这个字符串中(用于后续构造 filter 使用)</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> keys_;</span><br><span class="line">  <span class="comment">// 与 keys_ 配套, 每个被 AddKey() 方法追加的 key 在 </span></span><br><span class="line">  <span class="comment">// keys_ 中的起始索引.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">size_t</span>&gt; start_;</span><br><span class="line">  <span class="comment">// 每个新计算出来的 filter 都是一个字符串, </span></span><br><span class="line">  <span class="comment">// 都会被追加到 result_ 中.</span></span><br><span class="line">  <span class="comment">// filter block 保存的内容就是 result_.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> result_;</span><br><span class="line">  <span class="comment">// 是 keys_ 的列表形式, 临时变量, 每个成员是 Slice 类型,</span></span><br><span class="line">  <span class="comment">// 用于 policy_-&gt;CreateFilter() 生成构造器.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Slice&gt; tmp_keys_;   </span><br><span class="line">  <span class="comment">// 与 result_ 配套, 保存每个 filter 在 result_ </span></span><br><span class="line">  <span class="comment">// 中的起始偏移量.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">uint32_t</span>&gt; filter_offsets_; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// No copying allowed</span></span><br><span class="line">  FilterBlockBuilder(<span class="keyword">const</span> FilterBlockBuilder&amp;);</span><br><span class="line">  <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> FilterBlockBuilder&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>TableBuilder::Add()</code> 会在追加 k,v 的时候调用 FilterBlockBuilder 的<br><code>AddKey()</code> 将 k 追加到 FilterBlockBuilder 中, 其实现逻辑比较简单:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向 keys_ 中增加一个 key, 同时将 key 在 keys_ 中</span></span><br><span class="line"><span class="comment">// 起始偏移量保存到 start_ 向量中.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FilterBlockBuilder::AddKey</span><span class="params">(<span class="keyword">const</span> Slice&amp; key)</span> </span>&#123;</span><br><span class="line">  Slice k = key;</span><br><span class="line">  start_.push_back(keys_.size());</span><br><span class="line">  keys_.append(k.data(), k.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 TableBuilder flush 一个 data block 到文件后, 就要为其生成 filter, 该过程通过调用 FilterBlockBuilder 的 <code>StartBlock()</code> 达成:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为前一个已写入 table 文件的 data block 生成</span></span><br><span class="line"><span class="comment">// filter, 生成完毕后重置当前 FilterBlockBuilder 的状态为生成下一个</span></span><br><span class="line"><span class="comment">// filter 做准备.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FilterBlockBuilder::StartBlock</span><span class="params">(<span class="keyword">uint64_t</span> block_offset)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 计算以 block_offset 为起始地址的 block 对应的 filter 在</span></span><br><span class="line">  <span class="comment">// filter-offset 数组中的索引.</span></span><br><span class="line">  <span class="comment">// 默认每两 KB 数据就要生成一个 filter, </span></span><br><span class="line">  <span class="comment">// 如果 block size 超过 2KB, 则会生成多个 filters.</span></span><br><span class="line">  <span class="keyword">uint64_t</span> filter_index = (block_offset / kFilterBase);</span><br><span class="line">  assert(filter_index &gt;= filter_offsets_.size());</span><br><span class="line">  <span class="comment">// filter 是一个接一个构造的, 对应的索引数组也是对应着逐渐增长的, </span></span><br><span class="line">  <span class="comment">// 而非一次性构造好往里面填, 毕竟不知道要生成多少个 filters</span></span><br><span class="line">  <span class="keyword">while</span> (filter_index &gt; filter_offsets_.size()) &#123;</span><br><span class="line">    <span class="comment">// 这里虽然是个循环, 但是因为每次生成 filter </span></span><br><span class="line">    <span class="comment">// 都会清空相关状态(keys_, start_ 等等), </span></span><br><span class="line">    <span class="comment">// 所以下个循环并不会再生成 filter 了, 具体见</span></span><br><span class="line">    <span class="comment">// GenerateFilter() 的 if 部分.</span></span><br><span class="line">    GenerateFilter();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>StartBlock()</code> 方法有个循环调用 <code>GenerateFilter()</code> 方法的地方, 比较绕, 这部分逻辑要结合 <code>GenerateFilter()</code> if 部分和 <code>FilterBlockReader::KeyMayMatch()</code> 的 limit 计算部分一起看:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于即将生成的 block 不能与当前已写入 table 文件的 block </span></span><br><span class="line"><span class="comment">// 的 keys 共用 filter 了, 所以为当前已写入 table 文件的 block 的 </span></span><br><span class="line"><span class="comment">// keys_ 生成一个 filter. 生成完毕后清空当前 FilterBlockBuilder </span></span><br><span class="line"><span class="comment">// 相关相关状态以为下个 filter 计算所用.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FilterBlockBuilder::GenerateFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// keys_ 为空, 无须生成新的 filter.</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> num_keys = start_.size();</span><br><span class="line">  <span class="keyword">if</span> (num_keys == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 没有 key 需要计算 filter, 则直接把上一个 filter </span></span><br><span class="line">    <span class="comment">// 的结束地址(每个 filter 都是一个字符串, 所以保存到 result_ </span></span><br><span class="line">    <span class="comment">// 时候既有起始地址又有结束地址)填充到 filter-offset 数组中,</span></span><br><span class="line">    <span class="comment">// 这么做一方面为了对齐(方便 FilterBlockReader::KeyMayMatch() </span></span><br><span class="line">    <span class="comment">// 直接通过移位计算 filter 索引), 另一方面方便计算 filter 结束偏移量(</span></span><br><span class="line">    <span class="comment">// 就是 FilterBlockReader::KeyMayMatch() 计算 limit 的步骤).</span></span><br><span class="line">    filter_offsets_.push_back(result_.size());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将扁平化的 keys_ 转换为一个 key 列表.</span></span><br><span class="line">  <span class="comment">// 将 keys_ 大小放到 start_ 中作为最后一个 key 的结束地址, </span></span><br><span class="line">  <span class="comment">// 这样下面可以直接用 start_[i+1] - start_[i] 计算</span></span><br><span class="line">  <span class="comment">// 每个 key 长度.</span></span><br><span class="line">  start_.push_back(keys_.size());  </span><br><span class="line">  tmp_keys_.resize(num_keys);</span><br><span class="line">  <span class="comment">// 将字符串 keys_ 保存的每个 key 提取出来封装</span></span><br><span class="line">  <span class="comment">// 成 Slice 并放到 tmp_keys 列表中</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; num_keys; i++) &#123;</span><br><span class="line">    <span class="comment">// 第 i 个 key 在 keys 中的起始地址</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* base = keys_.data() + start_[i]; </span><br><span class="line">    <span class="comment">// 第 i 个 key 的长度</span></span><br><span class="line">    <span class="keyword">size_t</span> length = start_[i+<span class="number">1</span>] - start_[i];</span><br><span class="line">    <span class="comment">// 将第 i 个 key 封装成 Slice 并保存到 tmp_keys </span></span><br><span class="line">    <span class="comment">// 用于后续计算 filter </span></span><br><span class="line">    tmp_keys_[i] = Slice(base, length); </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为当前的 key 集合生成 filter.</span></span><br><span class="line">  <span class="comment">// 先将新生成的 filter 在 result_ 中的</span></span><br><span class="line">  <span class="comment">// 起始偏移量保存到 filter_offsets_.</span></span><br><span class="line">  filter_offsets_.push_back(result_.size());</span><br><span class="line">  <span class="comment">// 根据 tmp_keys_ 计算 filter 并追加到 result</span></span><br><span class="line">  policy_-&gt;CreateFilter(&amp;tmp_keys_[<span class="number">0</span>], <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(num_keys), &amp;result_);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重置当前 FilterBlockBuilder 相关的状态以方便为</span></span><br><span class="line">  <span class="comment">// 下个 data block 计算 filter 使用.</span></span><br><span class="line">  tmp_keys_.clear();</span><br><span class="line">  keys_.clear();</span><br><span class="line">  start_.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与 FilterBlockBuilder 相反, 将一个 filter block 解析出来, 然后用来查询某个 key 是否在某个 block 中. 其成员 <code>data_</code> 指向 filter block 起始地址, <code>offset_</code> 指向 filter block 尾部 offset array 的起始地址, 这也是 filter block 的末尾:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过过滤器查询 key 是否在以 block_offset 为起始地址的 block 中</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FilterBlockReader::KeyMayMatch</span><span class="params">(<span class="keyword">uint64_t</span> block_offset, <span class="keyword">const</span> Slice&amp; key)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 计算 filter 的时候是每隔 base 大小为一个区间, </span></span><br><span class="line">  <span class="comment">// 每个区间对应一个 filter. </span></span><br><span class="line">  <span class="comment">// 起始偏移量落在对应区间内的 blocks, </span></span><br><span class="line">  <span class="comment">// 会将其全部 keys 作为整体输入计算一个 filter. </span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 注意, 这里的算法正好解答了 </span></span><br><span class="line">  <span class="comment">// leveldb::FilterBlockBuilder::GenerateFilter() 的疑问, </span></span><br><span class="line">  <span class="comment">// 针对多出来那个重复的 filter offset, 会被自动跳过.</span></span><br><span class="line">  <span class="comment">// 下面这一步相当于除以 base 取商, 从而得到 block_offset </span></span><br><span class="line">  <span class="comment">// 对应的 filter-offset array 数组索引. </span></span><br><span class="line">  <span class="keyword">uint64_t</span> index = block_offset &gt;&gt; base_lg_;</span><br><span class="line">  <span class="keyword">if</span> (index &lt; num_) &#123;</span><br><span class="line">    <span class="comment">// 计算计算索引为 index 的 filter 的 offset, </span></span><br><span class="line">    <span class="comment">// 具体为先定位到保存目标 filter offset 的地址(每个地址长度为 4 字节), </span></span><br><span class="line">    <span class="comment">// 然后将其解码为一个无符号 32 位数.</span></span><br><span class="line">    <span class="keyword">uint32_t</span> start = DecodeFixed32(offset_ + index*<span class="number">4</span>);</span><br><span class="line">    <span class="comment">// 下面这个计算分两种情况理解:</span></span><br><span class="line">    <span class="comment">// - 当 index &lt; num_ - 1 时, 又要分为两个子情况</span></span><br><span class="line">    <span class="comment">//   - 如果 GenerateFilter() 方法在生成索引为 index 的 filter 时,</span></span><br><span class="line">    <span class="comment">//     至少多填充了一次 filter 结束偏移量到 filter-offset 数组, 那么</span></span><br><span class="line">    <span class="comment">//     该操作等价于取出索引为 index 的 filter 的结束偏移量</span></span><br><span class="line">    <span class="comment">//    (注意 GenerateFilter() 方法填充 filter 结束地址到</span></span><br><span class="line">    <span class="comment">//   filter-offset 的情况)</span></span><br><span class="line">    <span class="comment">//   - 如果 GenerateFilter() 方法在生成索引为 index 的 filter 时, </span></span><br><span class="line">    <span class="comment">//     仅为该 filter 在 filter-offset 数组填入了起始偏移量, 那么该操作</span></span><br><span class="line">    <span class="comment">//     相当于计算索引为 index+1 的 filter 的起始 offset.</span></span><br><span class="line">    <span class="comment">// - 当 index == num_ - 1 时, 也要再分为两个子情况</span></span><br><span class="line">    <span class="comment">//   - 同 index &lt; num_ - 1 时的第一个子情况.</span></span><br><span class="line">    <span class="comment">//   - 如果 GenerateFilter() 方法在生成索引为 index 的 filter 时, </span></span><br><span class="line">    <span class="comment">//     仅为该 filter 在 filter-offset 数组填入了起始偏移量, 那么该操作</span></span><br><span class="line">    <span class="comment">//     等价于直接取出索引为 index 的 filter 的结束偏移量. </span></span><br><span class="line">    <span class="comment">//     为什么看起来和第一个子情况一样? 其实不然. 因为 filter block 构成分四块, </span></span><br><span class="line">    <span class="comment">//     分别是&quot;一系列filters+filters-offset数组+filters和filters-offset</span></span><br><span class="line">    <span class="comment">//     数组的分隔符+base的log值&quot;, 这里提到的分隔符用的就是</span></span><br><span class="line">    <span class="comment">//     最后一个 filter 的结束地址). </span></span><br><span class="line">    <span class="comment">// 不管是哪种情况, limit - start 都是索引为 index 的 filter 的长度.</span></span><br><span class="line">    <span class="keyword">uint32_t</span> limit = DecodeFixed32(offset_ + index*<span class="number">4</span> + <span class="number">4</span>);</span><br><span class="line">    <span class="comment">// 注意 start 和 limit 都是相对于 data_ 的 offset 而非绝对地址.</span></span><br><span class="line">    <span class="keyword">if</span> (start &lt;= limit &amp;&amp; limit &lt;= <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(offset_ - data_)) &#123;</span><br><span class="line">      <span class="comment">// 取出 filter</span></span><br><span class="line">      Slice filter = Slice(data_ + start, limit - start);</span><br><span class="line">      <span class="comment">// 在 filter 中查询 key 是否存在</span></span><br><span class="line">      <span class="keyword">return</span> policy_-&gt;KeyMayMatch(key, filter);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (start == limit) &#123;</span><br><span class="line">      <span class="comment">// 如果 start == limit 说明索引为 index 的 filter 为空</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>TableBuilder 的 Finish() 会调用 FilterBlockBuilder 的 Finish() 完成 filter block 写入:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算最后一个 filter 对应的偏移量, 然后将 </span></span><br><span class="line"><span class="comment">// filter-offset array 并追加到 result_.</span></span><br><span class="line"><span class="comment">// 执行结束, result_ 保存的就是一个完整的 filter block</span></span><br><span class="line"><span class="function">Slice <span class="title">FilterBlockBuilder::Finish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 若 keys_ 不为空需要为其生成一个 filter</span></span><br><span class="line">  <span class="keyword">if</span> (!start_.empty()) &#123; </span><br><span class="line">    GenerateFilter();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下面马上会把每个 filter 在 result_ 中对应的</span></span><br><span class="line">  <span class="comment">// 起始地址也编码追加到 result_ 中, 这样前面是 filters, </span></span><br><span class="line">  <span class="comment">// 后面是 filters 的起始偏移量, 那这两部分反序列化时候怎么区分呢?</span></span><br><span class="line">  <span class="comment">// 我们提前记录追加 filters 总字节数就可以了.</span></span><br><span class="line">  <span class="comment">// array_offset 保存全部 filters 的总字节数, </span></span><br><span class="line">  <span class="comment">// 这个值在追加完全部 filters </span></span><br><span class="line">  <span class="comment">// 的起始地址后也会被追加到 result_ 作为最后一个元素, </span></span><br><span class="line">  <span class="comment">// 也是反序列化解析入口.</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint32_t</span> array_offset = result_.size();</span><br><span class="line">  <span class="comment">// 将每个 filter 在 result_ 中的起始偏移量编码追加到 result_</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; filter_offsets_.size(); i++) &#123;</span><br><span class="line">    PutFixed32(&amp;result_, filter_offsets_[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 filter-offset array 的起始偏移量编码追加到 result_, </span></span><br><span class="line">  <span class="comment">// 用于反序列化时区分 filters 与 filters 偏移量数组.</span></span><br><span class="line">  PutFixed32(&amp;result_, array_offset);</span><br><span class="line">  <span class="comment">// 将 base 的 log 值追加到 result, 用于反序列化时计算 base</span></span><br><span class="line">  result_.push_back(kFilterBaseLg);</span><br><span class="line">  <span class="comment">// 到此为止, result_ 已经是一个完整的 filter block 了, </span></span><br><span class="line">  <span class="comment">// 将其封装为 Slice 后返回.</span></span><br><span class="line">  <span class="keyword">return</span> Slice(result_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终在 TableBuilder 的 Finish() 将 filter block 刷入文件:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2 如果存在 filter block, 则将其写入文件; </span></span><br><span class="line"><span class="comment">// 写完后, filter_block_handle 保存着该 block </span></span><br><span class="line"><span class="comment">// 对应的 BlockHandle 信息, 包括起始偏移量和大小</span></span><br><span class="line"><span class="keyword">if</span> (ok() &amp;&amp; r-&gt;filter_block != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">  <span class="comment">// 写完 data blocks 该写入 filter block 了.</span></span><br><span class="line">  <span class="comment">// 注意 filter block 写入时不进行压缩.</span></span><br><span class="line">  WriteRawBlock(r-&gt;filter_block-&gt;Finish(), kNoCompression, </span><br><span class="line">  <span class="comment">// 将计算出 filter block 对应的 BlockHandle </span></span><br><span class="line">  <span class="comment">// 信息保存在 filter_block_handle 中.</span></span><br><span class="line">                &amp;filter_block_handle); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="224-写-meta-index-block">2.2.4 写 meta-index block</span></h3><p>这部分比较简单, 其在 TableBuilder 的 Finish() 方法里完成:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3 filter block 就是 table_format.md 中提到的 </span></span><br><span class="line"><span class="comment">// meta block, 写完 meta block 该写它对应的索引</span></span><br><span class="line"><span class="comment">// metaindex block 到文件中了.</span></span><br><span class="line"><span class="keyword">if</span> (ok()) &#123;</span><br><span class="line">  <span class="comment">// 虽然 meta block 有独立的 FilterBlockBuilder, </span></span><br><span class="line">  <span class="comment">// 但是其对应的 index block 用的还是通用的 </span></span><br><span class="line">  <span class="comment">// BlockBuilder.</span></span><br><span class="line">  <span class="function">BlockBuilder <span class="title">meta_index_block</span><span class="params">(&amp;r-&gt;options)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;filter_block != <span class="literal">nullptr</span>) &#123; </span><br><span class="line">    <span class="comment">// 如果 meta block 存在, 则将其对应的 key </span></span><br><span class="line">    <span class="comment">// 和 BlockHandle 写入 metaindex block,</span></span><br><span class="line">    <span class="comment">// 具体为 &lt;filter.Name, filter 数据地址&gt;.</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> key = <span class="string">&quot;filter.&quot;</span>;</span><br><span class="line">    key.append(r-&gt;options.filter_policy-&gt;Name());</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> handle_encoding;</span><br><span class="line">    filter_block_handle.EncodeTo(&amp;handle_encoding);</span><br><span class="line">    meta_index_block.Add(key, handle_encoding);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将 metaindex block 写入文件</span></span><br><span class="line">  WriteBlock(&amp;meta_index_block, &amp;metaindex_block_handle); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="225-写-data-index-block">2.2.5 写 data-index block</span></h3><p>这部分比较简单, 其在 TableBuilder 的 Finish() 方法里完成:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4 将 index block 写入 table 文件, 它里面保存的</span></span><br><span class="line"><span class="comment">// 都是 data block 对应的 BlockHandle.</span></span><br><span class="line"><span class="keyword">if</span> (ok()) &#123;</span><br><span class="line">  <span class="comment">// 最后构建的 data block 对应的 index block entry 还没有写入</span></span><br><span class="line">  <span class="keyword">if</span> (r-&gt;pending_index_entry) &#123; </span><br><span class="line">    r-&gt;options.comparator-&gt;FindShortSuccessor(&amp;r-&gt;last_key);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> handle_encoding;</span><br><span class="line">    r-&gt;pending_handle.EncodeTo(&amp;handle_encoding);</span><br><span class="line">    <span class="comment">// 写入最后构建的 data block 对应的 index block entry</span></span><br><span class="line">    r-&gt;index_block.Add(r-&gt;last_key, Slice(handle_encoding)); </span><br><span class="line">    r-&gt;pending_index_entry = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  WriteBlock(&amp;r-&gt;index_block, &amp;index_block_handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="226-写-footer">2.2.6 写 footer</span></h3><p>footer 是 sstable 文件的入口, 结构比较简单:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Footer 封装一个固定长度的信息, 它位于每个 table 文件的末尾. </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 在每个 sstable 文件的末尾是一个固定长度的 footer, </span></span><br><span class="line"><span class="comment">// 它包含了一个指向 metaindex block 的 BlockHandle</span></span><br><span class="line"><span class="comment">// 和一个指向 index block 的 BlockHandle 以及一个 magic number. </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Footer</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Footer() &#123; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">EncodeTo</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>* dst)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function">Status <span class="title">DecodeFrom</span><span class="params">(Slice* input)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Footer 长度编码后的长度. 注意, 它就固定这么长. </span></span><br><span class="line">  <span class="comment">// Footer 包含了一个 metaindex_handle、一个 index_handle、以及一个魔数. </span></span><br><span class="line">  <span class="keyword">enum</span> &#123;</span><br><span class="line">    <span class="comment">// Footer 长度, 两个 BlockHandle 最大长度 + 固定的 8 字节魔数</span></span><br><span class="line">    kEncodedLength = <span class="number">2</span>*BlockHandle::kMaxEncodedLength + <span class="number">8</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  BlockHandle metaindex_handle_;</span><br><span class="line">  BlockHandle index_handle_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其在 TableBuilder 的 Finish() 方法里完成写入:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5 最后将末尾的 Footer 写入 table 文件</span></span><br><span class="line"><span class="keyword">if</span> (ok()) &#123;</span><br><span class="line">  Footer footer;</span><br><span class="line">  footer.set_metaindex_handle(metaindex_block_handle);</span><br><span class="line">  footer.set_index_handle(index_block_handle);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> footer_encoding;</span><br><span class="line">  footer.EncodeTo(&amp;footer_encoding);</span><br><span class="line">  r-&gt;status = r-&gt;file-&gt;Append(footer_encoding);</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;status.ok()) &#123;</span><br><span class="line">    r-&gt;offset += footer_encoding.size();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/leveldb/" rel="tag"># leveldb</a>
              <a href="/tags/LSM-Tree/" rel="tag"># LSM-Tree</a>
              <a href="/tags/db/" rel="tag"># db</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/02/05/leveldb-annotations-4-iterator/" rel="prev" title="Leveldb 源码详解系列之四: 迭代器设计与实现">
      <i class="fa fa-chevron-left"></i> Leveldb 源码详解系列之四: 迭代器设计与实现
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/03/03/mapreduce-design-and-implementation/" rel="next" title="MapReduce: 分布式计算系统设计与实现">
      MapReduce: 分布式计算系统设计与实现 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Chienlung Cheung</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chienlung Cheung</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  













<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://Chienlung.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "https://chienlungcheung.github.io/2021/02/17/leveldb-annotations-5-sstable/";
    this.page.identifier = "2021/02/17/leveldb-annotations-5-sstable/";
    this.page.title = "Leveldb 源码详解系列之五: SSTable 设计与实现";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://Chienlung.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
