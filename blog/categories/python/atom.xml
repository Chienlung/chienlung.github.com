<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: python | Programath]]></title>
  <link href="http://Chienlung.github.com/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://Chienlung.github.com/"/>
  <updated>2013-08-07T08:39:55+08:00</updated>
  <id>http://Chienlung.github.com/</id>
  <author>
    <name><![CDATA[Chienlung]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[用python实现linux守护进程]]></title>
    <link href="http://Chienlung.github.com/blog/2013/08/06/yong-pythonshi-xian-linuxshou-hu-jin-cheng/"/>
    <updated>2013-08-06T19:47:00+08:00</updated>
    <id>http://Chienlung.github.com/blog/2013/08/06/yong-pythonshi-xian-linuxshou-hu-jin-cheng</id>
    <content type="html"><![CDATA[<p>昨天在微博看到<a href="http://www.vimer.cn/2010/08/%E7%94%A8python%E7%BC%96%E5%86%99linux%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B.html">这篇文章</a>,然后又看到<a href="http://colding.bokee.com/5277082.html">这个稍微详细点的解释</a>。本着好记性不如烂键盘，就自己把整个代码敲了一遍。不知道是吸收的知识量越来越大了，还是自己记性不如以前了，一看知道怎么回事，写出来或者讲出来就费点劲，甚至有点哑口。一定要多实践！APUE也要赶紧再看一遍。  <br/>
这个程序我自己敲的时候，加了一些自己的理解，注释里更多的解释了一下原理。</p>

<p>```python</p>

<h1>!/usr/bin/python</h1>

<h1>coding:utf-8</h1>

<p>import sys, os, time, atexit
from signal import SIGTERM
class Daemon:</p>

<pre><code>'''
通用Deamon类。
用法：通过继承Deamon类，然后重写该类的_run()方法即可。
'''
def __init__(self, pidfile, stdin = '/dev/null', stdout = '/dev/null', stderr = '/dev/null'):
    self.pidfile = pidfile
    self.stdin = stdin
    self.stdout = stdout
    self.stderr = stderr

def _daemonize(self):
    '''
    进行double-fork magic，详见APUE
    http://colding.bokee.com/5277082.html
    '''

    '''
    脱离父进程.
    为了避免被挂起，终止父进程，转到子进程后台中去运行
    '''
    try:
        pid = os.fork()
        if pid:
            sys.exit(0)
    except OSError, e:
        sys.stderr.write("fork #1 %d (%s)\n" % (e.errno, e.strerror))
        sys.exit(1)

    '''
    脱离终端。
    自立山头: 建立自己的会话，建立自己的进程组，自己当会话的leader，自己当进程组的组长。
    由于会话过程对控制终端的独占性，创建新对话以后进程就与控制终端脱离了。 
    '''
    os.setsid()

    '''
    修改当前目录。
    进程活动时，其工作目录所在的文件系统不能卸下。一般需要将工作目录改变到根目录。
    '''
    os.chdir('/')

    '''
    重新设置文件创建掩码。
    进程从创建它的父进程那里继承了文件创建掩模。
    它可能修改守护进程所创建的文件的存取位。为防止这一点，将文件创建掩模清除。
    '''
    os.umask(0)

    '''
    第二次fork。
    进程已经成为无终端的会话组长，但它可以重新申请打开一个控制终端。
    可以通过使进程不再成为会话组长来禁止进程重新打开控制终端。
    进程杀死自己，让本会话失去leader，让本进程组失去组长，
    这样就不可能去申请新的终端了。
    '''
    try:
        pid = os.fork()
        if pid:
            sys.exit(0)
    except OSError, e:
        sys.stderr.write("fork #2 %d (%s)" % (e.errno, e.strerror))

    sys.stdout.flush()
    sys.stderr.flush()
    si = file(self.stdin, 'r')
    so = file(self.stdout, 'a+')
    se = file(self.stderr, 'a+', 0)
    '''
    重定向标准输入/输出/错误
    '''
    os.dup2(si.fileno(), sys.stdin.fileno()) 
    os.dup2(so.fileno(), sys.stdout.fileno())
    os.dup2(se.fileno(), sys.stderr.fileno())

    '''
    注册程序退出时的函数，即删掉pidfile。
    '''
    atexit.register(self.delpid)
    '''

    创建保存daemon进程pid的文件。
    '''
    pid = str(os.getpid())
    file(self.pidfile, 'w+').write("%s\n" % pid)




def delpid(self):
    os.remove(self.pidfile)

def start(self):
    '''
    start the daemon
    '''

    '''
    检查pidfile看看是否存在Daemon进程，防止重复启动同一个daemon进程
    '''
    try:
        pf = file(self.pidfile, 'r')
        pid = int(pf.read().strip())
        pf.close()
    except IOError:
        pid = None

    if pid:
        message = 'pidfile %s already exist. Daemon already running?\n'
        sys.stderr.write(message % self.pidfile)
        sys.exit(1)

    '''
    start Daemon进程
    '''
    self._daemonize()
    self._run()

def stop(self):
    '''
    stop Daemon进程
    '''

    '''
    先检查要终止的daemon进程是否存在
    '''
    try:
        pf = file(self.pidfile, 'r')
        pid = int(pf.read().strip())
        pf.close()
    except IOError:
        pid = None

    if not pid:
        message = 'pidfile %s not exist. Daemon not running?\n'
        sys.stderr.write(message % self.pidfile)
        return
    '''
    终止daemon进程
    '''
    try:
        while 1:
            os.kill(pid, SIGTERM)
            time.sleep(0.1)
    except OSError, err:
        err = str(err)
        if err.find("No such process") &gt; 0:
            if os.path.exists(self.pidfile):
                os.remove(self.pidfile)
            else:
                print str(err)
                sys.exit(1)

def restart(self):
    '''
    重启daemon进程
    '''
    self.stop()
    self.start()

def _run(self):
    '''
    当你继承Daemon类时，你应该重写这个方法。
    这个函数会在该进程daemonized后被调用。
    '''
</code></pre>

<p>class MyDaemon(Daemon):</p>

<pre><code>def _run(self):
    while True:
        time.sleep(1)
</code></pre>

<p>if <strong>name</strong> == '<strong>main</strong>':</p>

<pre><code>daemon = MyDaemon('/tmp/my-first-daemon-example.pid')
if len(sys.argv) == 2:
    if 'start' == sys.argv[1]:
        daemon.start()
    elif 'stop' == sys.argv[1]:
        daemon.stop()
    elif 'restart' == sys.argv[1]:
        daemon.restart()
    else:
        print 'Unknown command'
        sys.exit(2)
    sys.exit(0)
else:
    print 'usage: %s start|stop|restart' % sys.argv[0]
    sys.exit(2)
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
</feed>
