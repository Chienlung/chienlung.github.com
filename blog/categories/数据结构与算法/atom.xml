<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 数据结构与算法 | Programath]]></title>
  <link href="http://Chienlung.github.com/blog/categories/数据结构与算法/atom.xml" rel="self"/>
  <link href="http://Chienlung.github.com/"/>
  <updated>2013-08-21T10:49:27+08:00</updated>
  <id>http://Chienlung.github.com/</id>
  <author>
    <name><![CDATA[Chienlung]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[增强版插入排序---------希尔排序]]></title>
    <link href="http://Chienlung.github.com/blog/2013/08/06/xi-er-pai-xu/"/>
    <updated>2013-08-06T13:32:00+08:00</updated>
    <id>http://Chienlung.github.com/blog/2013/08/06/xi-er-pai-xu</id>
    <content type="html"><![CDATA[<p>希尔排序是插入排序的加强版，我们知道插入排序是一种自适应的排序算法，即如果待排序文件基本有序的话，插入排序的速度将会非常快。<br/>
插入排序在把一个元素插入到合适位置时，需要从右向左一个一个的进行比较，如果是最小元素，比较次数更多了。如果把待排序文件改造成基本有序，那么排序速度就会很快了！希尔排序就是在插入排序的外面加了一道工序，这道工序用来对待排序文件进行预处理，处理成从任意元素开始，每隔h个元素构成的序列是有序的，即h-有序的。经过这道工序，然后进行插入排序，速度就很快了。<br/>
看下代码容易理解：  <br/>
```c
void
shellsort(Item a[], int l, int r)
{</p>

<pre><code>int i, j;
int h;
/* 下面这个计算步长的方法是Knuth发明的，现在还没找到最好的步长计算方法 */
for (h = 1; h &lt; (r - l) / 9; h = h * 3 + 1);

for (h; h &gt;0; h /= 3) {
    for (i = l + h; i &lt; r; i++) {
        j = i;
        Item v = a[j];
        while (j &gt; l &amp;&amp; less(v, a[j - h]) {
            a[j] = a[j - h];
            j -= h;
        }
        a[j] = v;
    }
}
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[基本排序算法]]></title>
    <link href="http://Chienlung.github.com/blog/2013/08/05/ji-ben-pai-xu-suan-fa/"/>
    <updated>2013-08-05T11:58:00+08:00</updated>
    <id>http://Chienlung.github.com/blog/2013/08/05/ji-ben-pai-xu-suan-fa</id>
    <content type="html"><![CDATA[<p>这里总结的基本排序算法包括选择排序、插入排序、冒泡排序。<br/>
对于随机组合的n个数据进行排序时，这三个算法的时间复杂度与 $O(n<sup>2</sup> )$ 成正比，但是不要看不起这几个算法，对于小规模文件或者具有特殊结构（比如基本有序）的文件，这些算法比一些复杂算法的效率要高。这三个算法都不适合大型随机组合的文件，因为即使计算机运行速度非常快也是非常耗时的。下一篇文章要说的希尔排序算个例外，希尔排序的时间复杂度要低于 $O(n<sup>2</sup> )$ ，而是与 $O(n<sup>3/2</sup> )$ 成正比，适合中等大小的文件排序。</p>

<h2>选择排序</h2>

<p>我觉得这是一种最直觉的排序算法。首先，选出数组中的最小的元素，将它与数组中第一个元素进行交换；然后，选出次小的元素，将它与数组中的第二个元素进行交换。按照这个方法进行下去，直到整个数组排完序。<br/>
整个排序过程分成<strong>比较-交换</strong>两个大步骤。比较时，首先是从N个元素挑出最小值，需要比较N-1次；然后是从N-1个元素挑出次小值，需要比较N-2次...，所以可以算出比较次数为（N-1）+（N-2）+...+1 。交换时，每一次交换，都将一个元素放在了它最终的位置上，所以交换的次数为N-1（最后一个元素不需要交换）。所以整体看来，执行时间由比较次数决定。<br/>
后面可以看出尽管这三种基本排序算法的比较次数是一个数量级的 $ (O(n<sup>2</sup> )) $ ，但是选择排序的交换次数却是线性的，所以当数据项很大时由于交换操作会涉及大量复制，所以交换操作最少的选择排序是三者中最快的。<br/>
下面是选择排序的C语言代码：<br/>
```c</p>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;stdlib.h></h1>

<p>typedef int Item;</p>

<h1>define key(A)  (A) /<em> 取出项A的关键字（用于比较时用） </em>/</h1>

<h1>define less(A, B) (key(A) &lt; key(B)) /<em> A的关键字是否小于B的关键字 </em>/</h1>

<h1>define exch(A, B) { Item t = A; A = B; B = t; } /<em> 交换项A和项B </em>/</h1>

<p>void
selection(Item a[], int l, int r)
{
  int i, j;
  for (i = l; i &lt; r; i++) {</p>

<pre><code>  int min = i;
  for (j = i + 1; j &lt;= r; j++)
      if (less(a[j], a[min])) min = j;
  exch(a[i], a[min]);
</code></pre>

<p>  }
}</p>

<p>int
main(int argc, char <em>argv[])
{
  int n = atoi(argv[1]);
  int </em>a = malloc(n * sizeof(int));
  int i = 0;
  while(i &lt; n &amp;&amp; scanf("%d", &amp;a[i]) == 1) i++;
  selection(a, 0, n - 1);
  for (i = 0; i &lt; n; i++) printf("%d ", a[i]);
  printf("\n");
  return 0;
}</p>

<p>```</p>

<h2>插入排序</h2>

<p>插入排序类似与打扑克时的抽牌和排大小，一摞扑克放在那，轮到你时，你在里面抽一张，然后跟手里已经抽到的比较一下，把它放到合适的位置，然后继续。等到抽完牌了，手里到牌也排好序了。<br/>
先写个简单的插入排序算法：<br/>
```c</p>

<h1>define compexch(A, B) if (less(B, A)) exch(A, B)</h1>

<p>void
insert(Item a[], int l, int r)
{</p>

<pre><code>int i, j;
for (i = l + 1; i &lt;= r; i++) /* 外层循环相当于抽牌 */
    for (j = i; j &gt; l; j--)/* 内层循环相当于排大小 */
        compexch(a[j - 1], a[j]);
</code></pre>

<p>}
<code>  
上面这段代码可以优化。再想象抽牌排大小过程，抽到新牌后，跟手里已经抽到的牌从右向左比较，如果比新牌大就往右挪一个位置，然后跟下个比，直到比新牌小为止，再左边的就不用比了，也就是说可以跳出内层循环了。这个改进可以使插入排序变成一个适应性排序算法，当待排序的文件基本有序时，插入排序的时间可以接近线性时间，与之对比的是选择排序是非适应性的，不管待排序文件是否基本有序，时间复杂度都是二次的。另外，设置观察哨，可以将内层循环里的比较操作由两次变为一次。  
改进后的代码：   
</code>c
void
insert(Item a[], int l, int r)
{</p>

<pre><code>int i, j;
for (i = r; i &gt; l; i--) /* 把最小值换到起始位置当观察哨 */
    compexch(a[i - 1], a[i]);
for (i = l + 2; i &lt;= r; i++) {
    int j = i;
    Item v = a[i];
    while (a[j] &gt; a[j - 1]) {
        a[j] = a[j - 1];
        j--;
    }
    a[j] = v;
}
</code></pre>

<p>}
```</p>

<h2>冒泡排序</h2>

<p>冒泡排序实际上是一种选择排序，每次也是挑一个放到前面合适的位置，但是跟选择排序不同的是，每次挑选合适的元素时，会把后面的各个元素也大体排一下，所以在冒泡排序中，随着排序的进行，后面是越来越有序，而选择排序不会产生这种效果。<br/>
下面是C代码： <br/>
```c
void
bubble(Item a[], int l, int r)
{</p>

<pre><code>int i, j;
for (i = l; i &lt; r; i++) {
    for (j = r; j &gt; i; j++)
        compexch(a[j - 1], a[j]);
}
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
</feed>
