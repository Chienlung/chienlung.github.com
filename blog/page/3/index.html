
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Programath</title>
  <meta name="author" content="Chienlung">

  
  <meta name="description" content="我打算做一遍Cracking the Coding Interview里面的题目，希望自己坚持做下去。题目挺好的。
">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://Chienlung.github.com/blog/page/3/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Programath" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Programath</a></h1>
  
    <h2>善战者无名。LoveLY!o(∩_∩)o。</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:Chienlung.github.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/07/14/cracking-the-coding-interview-yao-jian-chi-zuo-wan-a-hun-dan/">Cracking the Coding Interview 要坚持做完啊魂淡</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-07-14T22:34:00+08:00" pubdate data-updated="true">Jul 14<span>th</span>, 2013</time>
        
         | <a href="/blog/2013/07/14/cracking-the-coding-interview-yao-jian-chi-zuo-wan-a-hun-dan/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>我打算做一遍Cracking the Coding Interview里面的题目，希望自己坚持做下去。题目挺好的。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/07/13/poj-1006-biorhythms-acdai-ma/">Poj 1006 Biorhythms AC代码</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-07-13T10:21:00+08:00" pubdate data-updated="true">Jul 13<span>th</span>, 2013</time>
        
         | <a href="/blog/2013/07/13/poj-1006-biorhythms-acdai-ma/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>其实这个题挺简单的，本来不想写解题报告，但是提交的时候连续WA，后来想自己思路不够缜密，这个题最关键的是对输入p,e,i这三个值的理解，这里牵扯到一个定语从句到底修饰谁的语法问题&#8217;The values p, e, and i are the number of days from the beginning of the current year at which the physical, emotional, and intellectual cycles peak, respectively.&#8217;这个句子中到at which修饰的是&#8217; the number&#8217;而不是&#8217;the beginning&#8217;，要是理解错了会发现矛盾。也就是说the beginning of the current year记为0，那么p,e,i指的是在日期p发生physical peak，在日期e发生emotional peak，在日期i发生intellectual peak，但前面这些日期p,e,i不一定是current year各个peak第一次发生的日期，而题目指出给定的日期d可能小于p,e,i，所以要先分别对p,e,i各自做一下模运算求出current year每个peak第一次发生的时间，而这三个第一次发生的时间可能重合即是一个triple peak，而d可能比这个时间小。下面是代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span>
</span><span class='line'><span class="nf">triple_peak</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">e</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">d</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>
</span><span class='line'>  <span class="n">p</span> <span class="o">%=</span> <span class="mi">23</span><span class="p">,</span> <span class="n">e</span> <span class="o">%=</span> <span class="mi">28</span><span class="p">,</span> <span class="n">i</span> <span class="o">%=</span> <span class="mi">33</span><span class="p">;</span><span class="c1">//求各个peak第一次发生的时间</span>
</span><span class='line'>  <span class="c1">//p + 23 * m == e + 28 * n == i + 33 * k</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">p</span> <span class="o">-</span> <span class="n">e</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">p</span> <span class="o">-</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
</span><span class='line'>  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">j</span> <span class="o">=</span> <span class="mi">23</span> <span class="o">*</span> <span class="n">m</span><span class="p">;</span>
</span><span class='line'>      <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">t1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">28</span><span class="p">;</span>
</span><span class='line'>      <span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">t2</span> <span class="p">)</span> <span class="o">/</span> <span class="mi">33</span><span class="p">;</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="mi">28</span> <span class="o">*</span> <span class="n">n</span> <span class="o">==</span> <span class="n">j</span> <span class="o">+</span> <span class="n">t1</span> <span class="o">&amp;&amp;</span> <span class="mi">33</span> <span class="o">*</span> <span class="n">k</span> <span class="o">==</span> <span class="n">j</span> <span class="o">+</span> <span class="n">t2</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">+</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="n">d</span><span class="p">)</span>
</span><span class='line'>          <span class="k">break</span><span class="p">;</span>
</span><span class='line'>      <span class="n">m</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">d</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="n">p</span> <span class="o">-</span> <span class="n">d</span><span class="p">;</span>
</span><span class='line'>  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Case %d: the next triple peak occurs in %d days.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span>
</span><span class='line'><span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="k">while</span> <span class="p">(</span><span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d%d%d%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
</span><span class='line'>      <span class="n">triple_peak</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
</span><span class='line'>      <span class="n">c</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/07/11/poj-1002-487-3279-acdai-ma/">Poj 1002 487-3279 AC代码</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-07-11T21:07:00+08:00" pubdate data-updated="true">Jul 11<span>th</span>, 2013</time>
        
         | <a href="/blog/2013/07/11/poj-1002-487-3279-acdai-ma/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>题目要把一个电话本里面的所有重复的电话号码转成标准格式，即形如102-1129的格式，并且输出其重复次数，号码输出时按字典序输出。如果没有重复的就输出No duplicates.。</p>

<p>这个题目我首先就想用STL，但是一想算了没什么锻炼。然后就想用bitmap，bitmap节省空间，并且还有顺序符合那个字典序要求，但是算了下所有的号码是从000-0000到999-9999，一共1000万个数，用bitmap得耗费125MB，还是算了。所以就用了trie，这个数据结构相当节省空间，而且从上向下从左向右遍历符合字典序要求。我还想用trie的变形就是TST（ternary search trie,即三路搜索线索），TST更加节省空间。标准trie虽然可以复用某些分支，但是在输入不够随机的时候，可能会产生许多空桶。但是在写标准trie的时候因为该死的calloc害我浪费大量时间，后来就没写。</p>

<p>唉，真的，如果因为不熟练造成的无谓的错误真的会让自己淹没在细节中。calloc会初始化分配好的内存，但素，第一个参数不要写成0啊魂淡！！！！开始不知道这里，不停的设置断点进行debug，查看内存的时候我都要怀疑自己对递归的理解了啊魂淡！呵呵:-)，不过，因为这个错误，对eclipse环境也更加熟悉了，而且为了规避递归出错（因为我实在不明白内存为什么是那个样子 TAT）所以还写了个非递归版本的插入操作。</p>

<p>下面是代码，里面关键地方都有注释。题目请戳<a href="http://poj.org/problem?id=1002">487-3279</a>。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;string.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">dic</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span><span class="c1">//这个数组相当于一个map，把输入的电话号码中到大写字母映射为相应的数字，赋值见main函数。</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/*</span>
</span><span class='line'><span class="cm"> * 一共十个数字（0-9），所以trie树每个节点最多十个儿子。</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="cp">#define CHILD_NUM 10</span>
</span><span class='line'>
</span><span class='line'><span class="k">typedef</span> <span class="k">struct</span> <span class="n">trie_node</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">size_t</span> <span class="n">count</span><span class="p">;</span><span class="c1">//记录号码出现次数</span>
</span><span class='line'>  <span class="kt">char</span> <span class="n">phone_num</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span><span class="c1">//存放出现次数超过一次的电话号码，共七位，不包含‘-’。</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">trie_node</span> <span class="o">*</span><span class="n">child</span><span class="p">[</span><span class="n">CHILD_NUM</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span> <span class="n">trie_node</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">duplicates_flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/*</span>
</span><span class='line'><span class="cm"> * 把输入中的字母转换为数字，把数字字符转换为数字。忽略无效的‘-’。</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="kt">void</span>
</span><span class='line'><span class="nf">letter_to_digit</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">result</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;-&#39;</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>          <span class="k">if</span> <span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="sc">&#39;A&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;</span> <span class="sc">&#39;Z&#39;</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>              <span class="n">result</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">dic</span><span class="p">[</span><span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>
</span><span class='line'>          <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>              <span class="n">result</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
</span><span class='line'>          <span class="p">}</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/*</span>
</span><span class='line'><span class="cm"> * 插入每个电话号码到trie树中</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="kt">void</span>
</span><span class='line'><span class="nf">insert_trie</span><span class="p">(</span><span class="n">trie_node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">result</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">char</span> <span class="n">i</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
</span><span class='line'>  <span class="n">trie_node</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">node</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">trie_node</span><span class="o">*</span><span class="p">)</span><span class="n">calloc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">trie_node</span><span class="p">));</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="mi">6</span><span class="p">)</span> <span class="p">{</span><span class="c1">//到第七个数字的时候这个电话号码中每个数字就都要插入完成了。要记录该号码出现次数。</span>
</span><span class='line'>      <span class="n">tmp</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'>      <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span><span class="c1">//仅仅把出现次数超过1的电话号码进行存储，其它就不浪费时间存了。</span>
</span><span class='line'>          <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">7</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>              <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">phone_num</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span><span class='line'>          <span class="p">}</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">insert_trie</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">result</span><span class="p">,</span> <span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/*</span>
</span><span class='line'><span class="cm"> * 查询重复号码串，若有出现超过一次的就输出该号码。</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="kt">void</span>
</span><span class='line'><span class="nf">query_trie</span><span class="p">(</span><span class="n">trie_node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
</span><span class='line'>  <span class="n">trie_node</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">return</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CHILD_NUM</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">tmp</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>          <span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>              <span class="n">duplicates_flag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="c1">//执行到这里说明电话簿里出现了重复号码。标志置为1。</span>
</span><span class='line'>              <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">7</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                  <span class="k">if</span><span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;-&quot;</span><span class="p">);</span><span class="c1">//记得输出‘-’</span>
</span><span class='line'>                  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">phone_num</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
</span><span class='line'>              <span class="p">}</span>
</span><span class='line'>              <span class="n">printf</span><span class="p">(</span><span class="s">&quot; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
</span><span class='line'>          <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>              <span class="n">query_trie</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
</span><span class='line'>          <span class="p">}</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span>
</span><span class='line'><span class="nf">destroy_trie</span><span class="p">(</span><span class="n">trie_node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CHILD_NUM</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>          <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>              <span class="n">destroy_trie</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span><span class='line'>          <span class="p">}</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span>
</span><span class='line'><span class="nf">process</span><span class="p">(</span><span class="n">trie_node</span> <span class="o">*</span><span class="n">trie_root</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">char</span> <span class="n">result</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>
</span><span class='line'>  <span class="n">letter_to_digit</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
</span><span class='line'>  <span class="n">insert_trie</span><span class="p">(</span><span class="n">trie_root</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span>
</span><span class='line'><span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">size_t</span> <span class="n">n</span><span class="p">;</span>
</span><span class='line'>  <span class="cm">/*</span>
</span><span class='line'><span class="cm">  * 好坑爹！！！我开始设置的数组长度是20，老是WA，题目看了好几遍也没说输入字符串到底多大。</span>
</span><span class='line'><span class="cm">  * 特么的最后没招了，把这个设置成2000，立马过了！！！！</span>
</span><span class='line'><span class="cm">  */</span>
</span><span class='line'>  <span class="kt">char</span> <span class="n">str</span><span class="p">[</span><span class="mi">2000</span><span class="p">];</span>
</span><span class='line'>  <span class="n">trie_node</span> <span class="o">*</span><span class="n">trie_root</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">dic</span><span class="p">[</span><span class="sc">&#39;A&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dic</span><span class="p">[</span><span class="sc">&#39;B&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dic</span><span class="p">[</span><span class="sc">&#39;C&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span><span class='line'>  <span class="n">dic</span><span class="p">[</span><span class="sc">&#39;D&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dic</span><span class="p">[</span><span class="sc">&#39;E&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dic</span><span class="p">[</span><span class="sc">&#39;F&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span><span class='line'>  <span class="n">dic</span><span class="p">[</span><span class="sc">&#39;G&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dic</span><span class="p">[</span><span class="sc">&#39;H&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dic</span><span class="p">[</span><span class="sc">&#39;I&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
</span><span class='line'>  <span class="n">dic</span><span class="p">[</span><span class="sc">&#39;J&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dic</span><span class="p">[</span><span class="sc">&#39;K&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dic</span><span class="p">[</span><span class="sc">&#39;L&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</span><span class='line'>  <span class="n">dic</span><span class="p">[</span><span class="sc">&#39;M&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dic</span><span class="p">[</span><span class="sc">&#39;N&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dic</span><span class="p">[</span><span class="sc">&#39;O&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
</span><span class='line'>  <span class="n">dic</span><span class="p">[</span><span class="sc">&#39;P&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dic</span><span class="p">[</span><span class="sc">&#39;R&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dic</span><span class="p">[</span><span class="sc">&#39;S&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
</span><span class='line'>  <span class="n">dic</span><span class="p">[</span><span class="sc">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dic</span><span class="p">[</span><span class="sc">&#39;U&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dic</span><span class="p">[</span><span class="sc">&#39;V&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
</span><span class='line'>  <span class="n">dic</span><span class="p">[</span><span class="sc">&#39;W&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dic</span><span class="p">[</span><span class="sc">&#39;X&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dic</span><span class="p">[</span><span class="sc">&#39;Y&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>  <span class="k">while</span> <span class="p">(</span><span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">trie_root</span> <span class="o">=</span> <span class="p">(</span><span class="n">trie_node</span><span class="o">*</span><span class="p">)</span><span class="n">calloc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">trie_node</span><span class="p">));</span><span class="c1">//每次都要destroy这棵trie树，所以每次都要新建根节点</span>
</span><span class='line'>      <span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>          <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
</span><span class='line'>          <span class="n">process</span><span class="p">(</span><span class="n">trie_root</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>      <span class="n">duplicates_flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="c1">//判断是否有重复电话号码的标志</span>
</span><span class='line'>      <span class="n">query_trie</span><span class="p">(</span><span class="n">trie_root</span><span class="p">);</span>
</span><span class='line'>      <span class="n">destroy_trie</span><span class="p">(</span><span class="n">trie_root</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="n">duplicates_flag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>          <span class="n">printf</span><span class="p">(</span><span class="s">&quot;No duplicates.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/07/10/poj-1001-expnentiation-acdai-ma/">Poj 1001 Expnentiation AC代码</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-07-10T23:56:00+08:00" pubdate data-updated="true">Jul 10<span>th</span>, 2013</time>
        
         | <a href="/blog/2013/07/10/poj-1001-expnentiation-acdai-ma/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>自己过去都没正儿八经写过高精度算法，看<a href="http://poj.org/problem?id=1001">poj 1001 Exponentiation</a>通过率不太高，写个试试，没想到一次AC。思路很简单，细节有点小繁杂。数组a始终保存求幂的那个原数;数组b开始跟a内容一样，但是后面累成了几次以后b保存的就是中间结果;数组c保存数组a与数组b的乘积，每次计算完毕把数组c中内容后拷贝到数组b中。最后结果保存在数组c中。关键地方代码做了注释。（再不写博客，就快把markdown语法忘光了。。。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;string.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">100</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">100</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span>
</span><span class='line'><span class="nf">exponentiation</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="kt">int</span>  <span class="n">n</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">p</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">dot</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">c1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">c2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">digit_num_a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">digit_num_b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">memset</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">a</span><span class="p">));</span>
</span><span class='line'>  <span class="n">memset</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">b</span><span class="p">));</span>
</span><span class='line'>  <span class="n">memset</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">c</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="k">while</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;0&#39;</span><span class="p">)</span> <span class="n">p</span><span class="o">++</span><span class="p">;</span><span class="c1">//记录最高位有效数字位置，以去掉输入中前缀0</span>
</span><span class='line'>  <span class="k">while</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;0&#39;</span><span class="p">)</span> <span class="n">len</span><span class="o">--</span><span class="p">;</span><span class="c1">//去掉后缀无效0</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span><span class="p">)</span> <span class="n">len</span><span class="o">--</span><span class="p">;</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span><span class="c1">//若幂为1，则直接输出有效数字</span>
</span><span class='line'>      <span class="k">while</span> <span class="p">(</span><span class="n">p</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>          <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%c&quot;</span><span class="p">,</span><span class="n">r</span><span class="p">[</span><span class="n">p</span><span class="p">]);</span>
</span><span class='line'>          <span class="n">p</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>      <span class="k">return</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">p</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">,</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;.&#39;</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>          <span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
</span><span class='line'>          <span class="n">digit_num_a</span><span class="o">++</span><span class="p">;</span><span class="c1">//记录有多少个数字</span>
</span><span class='line'>          <span class="n">digit_num_b</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>          <span class="n">dot</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span><span class="c1">// 记录小数点位置</span>
</span><span class='line'>          <span class="n">j</span><span class="o">--</span><span class="p">;</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">dot</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">dot</span> <span class="o">*=</span> <span class="n">n</span><span class="p">;</span><span class="c1">//求幂完毕后小数点应在的位置</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">memset</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">c</span><span class="p">));</span>
</span><span class='line'>      <span class="n">temp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">c1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">c2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>      <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">digit_num_a</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>          <span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">digit_num_b</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">,</span> <span class="n">h</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>              <span class="n">temp</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">c1</span><span class="p">;</span>
</span><span class='line'>              <span class="n">c1</span> <span class="o">=</span> <span class="n">temp</span> <span class="o">/</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'>              <span class="n">temp</span> <span class="o">=</span>  <span class="n">temp</span> <span class="o">%</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>              <span class="n">c</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">+=</span> <span class="n">temp</span><span class="p">;</span>
</span><span class='line'>              <span class="n">c</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">+=</span> <span class="n">c2</span><span class="p">;</span>
</span><span class='line'>              <span class="n">c2</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">/</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'>              <span class="n">c</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">%</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'>          <span class="p">}</span>
</span><span class='line'>          <span class="k">if</span> <span class="p">(</span><span class="n">c1</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>              <span class="n">c</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">=</span> <span class="n">c1</span><span class="p">;</span>
</span><span class='line'>              <span class="n">c1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>          <span class="p">}</span>
</span><span class='line'>          <span class="k">if</span> <span class="p">(</span><span class="n">c2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>              <span class="n">c</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">+=</span> <span class="n">c2</span><span class="p">;</span>
</span><span class='line'>              <span class="n">c2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>          <span class="p">}</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>      <span class="c1">//把第j轮结果拷贝到b[]中</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span> <span class="n">c</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">h</span><span class="o">--</span><span class="p">;</span>
</span><span class='line'>      <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">h</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>          <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>      <span class="n">digit_num_b</span> <span class="o">=</span> <span class="n">h</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span> <span class="n">c</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">h</span><span class="o">--</span><span class="p">;</span>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">h</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span><span class="c1">//记录尾部第一个有效数字的位置</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>          <span class="k">break</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">h</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">dot</span><span class="p">;</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span>
</span><span class='line'>      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">dot</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">dot</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;.&quot;</span><span class="p">);</span>
</span><span class='line'>      <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">dot</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span>
</span><span class='line'>          <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span>
</span><span class='line'><span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">char</span> <span class="n">r</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
</span><span class='line'>  <span class="k">while</span> <span class="p">(</span><span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%s%d&quot;</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>          <span class="n">exponentiation</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/06/04/yong-que-ding-xing-you-xian-zi-dong-ji-dfashi-xian-kmpsuan-fa/">用确定性有限自动机DFA实现KMP算法</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-06-04T14:43:00+08:00" pubdate data-updated="true">Jun 4<span>th</span>, 2013</time>
        
         | <a href="/blog/2013/06/04/yong-que-ding-xing-you-xian-zi-dong-ji-dfashi-xian-kmpsuan-fa/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>字符串搜索或者字符串匹配这个应用很普遍，比如我们日常用的编辑器中按下Ctrl+F都能调出搜索对话框来查找某个字符串。在KMP出现之前最常用的办法是暴力搜索，就是一一比对文本和子串直到找到该子串或者文本结束，虽然简单粗暴，但是如果被搜索的子串如果没有太多的重复字符，这个方法还是非常高效，最坏情况的时间复杂度为O（nm），n为文本长度，m为要查找的子串长度。后面我把搜索子串所用的文本叫做text，把被搜索的子串叫做pattern。</p>

<p>暴力搜索算法比较简单，先上个代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">search</span><span class="o">(</span><span class="n">String</span> <span class="n">pat</span><span class="o">,</span> <span class="n">String</span> <span class="n">txt</span><span class="o">)</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">M</span> <span class="o">=</span> <span class="n">pat</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="n">txt</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
</span><span class='line'>  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="o">-</span><span class="n">M</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>      <span class="kt">int</span> <span class="n">j</span><span class="o">;</span>
</span><span class='line'>      <span class="k">for</span> <span class="o">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">M</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>          <span class="k">if</span> <span class="o">(</span><span class="n">txt</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">!=</span> <span class="n">pat</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">))</span>
</span><span class='line'>              <span class="k">break</span><span class="o">;</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>      <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">M</span><span class="o">)</span>
</span><span class='line'>          <span class="k">return</span> <span class="n">i</span><span class="o">;</span><span class="c1">//found, return the beginning position of the substring</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">N</span><span class="o">;</span><span class="c1">//not found</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>详细搜索过程见下图：
<img src="../_images_posted/Brute-force_substring_search.jpg" alt="Brute-force substring search" /></p>

<p>暴力搜索一个很不好的地方就是指向文本的指针i老是需要回退，没有好好利用已经检测过的字符，老是重复检测。所以Knuth等大神发明了KMP算法，这个算法的精要就是文本指针不需要回退，而是回退指向子串的指针，从而避免重复检测。但是如何回退指向子串的指针呢，这就用到了确定性自动机。(未完。上传图片出现问题，不开心。。。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/05/18/leveldbshi-xian-shuo-ming/">LevelDB实现说明</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-05-18T16:09:00+08:00" pubdate data-updated="true">May 18<span>th</span>, 2013</time>
        
         | <a href="/blog/2013/05/18/leveldbshi-xian-shuo-ming/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><em>本文档根据<a href="http://leveldb.googlecode.com/svn/trunk/doc/impl.html">Implementation notes</a>翻译，为了更加严谨，有些地方会保留对应的英文用法。如果有不妥的地方，恳请大家斧正，不吝感激！抱拳。</em></p>

<h1>文件（Files）</h1>

<p>leveldb的实现本质上与单一的<a href="http://labs.google.com/papers/bigtable.html">Bigtable tablet(section 5.3)</a>的表现形式（representation）相似。但是构成这种表现形式（representation）的文件的组织结构有点不同，下面会解释。
每个数据库通过存储在一个目录下的一组文件来表示。正如下面列出来的，存在多种不同文件类型：</p>

<p><em>日志文件（Log files）</em></p>

<p>日志文件(<code>*.log</code>)存储了一系列最近的更新。每一个更新都被追加到当前日志文件中。当日志文件达到一个预定义的大小时（默认大约4MB），它就会被转换成一个有序表（sorted table，下面会谈到），同时一个新的日志文件会为将来的更新而被创建。</p>

<p>当前日志文件的一个副本会被保存在一个内存结构（in-memory structure，即<code>memtable</code>）中。每一次执行读取操作的时候，这个副本都会被查询，这样读取操作就能反映所有被记录的更新。</p>

<p><em>有序表（Sorted tables）</em></p>

<p>一个有序表（<code>*.sst</code>）存储了一系列按键（key）序排列的项。每个项要么是对应该键（key）的值（value），要么是该键（key）的删除标记（deletion marker)。（删除标记被保存用来隐藏存在于老版本的有序表中的过时的值（values）。）</p>

<p>有序表的集合被组织成一系列层级（levels）。有序表由一个日志文件生成，被放在一个特殊的<code>young</code>层级（也被叫做level-0）上。当young文件（young files）的数目超过一个特定的阈值（目前是4），所有的young文件跟所有与自己重叠的level-1层级的文件被合并在一起，来产生一系列新的level-1文件（合并后的数据每2MB生成一个新的level-1文件。）。</p>

<p>young level上的文件可能包含相互重叠的键，但是其它level各自内部的文件相互之间没有重叠的键范围（key ranges）。考虑L>=1的level-L。当level-L上文件的组合大小超过10的L次方MB（即level-1为10MB，level-2为100MB，&#8230;），level-L上的一个文件就会和level-(L+1)上的与自己重叠的文件合并起来为level-(L+1)组成一组新文件。这些合并有一个渐进迁移的效果，即通过大块读写操作（bulk reads and writes）逐渐把来自young level的新的更新迁移到最高level上（这样就可以最小化昂贵的搜索操作(seeks)）。</p>

<p><em>配置文件（Manifest）</em></p>

<p>一个MANIFEST文件列出了构成每个层级的有序表的集合，相应的键范围，以及其它重要元数据。每次数据库被重新打开的时候，都会有一个新的MANIFEST文件（在文件名上带有一个嵌入的号码）被创建。MANIFEST文件会被格式化为一个日志（log），对服务状态（serving state，比如文件被添加或者被移除）作出的改变会被追加到这个日志里。</p>

<p><em>Current文件</em></p>

<p>CURRENT是一个简单的文本文件，包含了最新的MANIFEST文件的名字。</p>

<p><em>信息日志(Info logs)</em></p>

<p>指示性信息（Informatioal messages）被打印到名为LOG和LOG.old的文件中。</p>

<p><em>其它（Others）</em></p>

<p>被用于各种五花八门目的的其它文件也可能会出现（比如LOCK，*.dbtmp)。</p>

<h1>Level 0</h1>

<p>当日志文件增长到一个特定大小（默认是1MB，它上面还说默认是4MB，这里又来了个1MB，莫名其妙的）：</p>

<p>》》创建一个全新的memtable（文档开头说了，这个内存结构用来保存日志文件的副本）和日志文件，并把将来的更新写到它俩这里（我觉得log file在磁盘上，而memtable是log file在内存里的一个映像，每次查询时查询的是memtable，因为它在内存里所以速度很快。所以每次写既要写memtable，又要写log file。）</p>

<p>》》在后台做下面的事情：</p>

<p>》》》》把前一个memtable的内容写到一个sstable(这个在这没有明说，我觉得就是前面提到的那个排序表即sorted table)</p>

<p>》》》》丢弃前一个memtable</p>

<p>》》》》删除老的日志文件和老的memtable</p>

<p>》》》》把这个新的sstable增加到young（level-0）level上</p>

<h1>压缩（Compactions）</h1>

<p>当level L的大小超过它的限制的时候，我们在后台线程压缩它。压缩时会从level L取一个文件，并从level L+1 取出与这个文件重叠的所有文件。注意，如果一个level-L文件只与一个level-(L+1)文件部分重叠，level-(L+1)上的这个文件仍然会整个被作为这个压缩过程的输入并且会在压缩完毕后被丢弃。另外，因为level-0很特殊（level-0上的文件可能互相之间交叠），所以我们要特殊对待从level-0到level-1的压缩：一个level-0压缩可能会取出多个level-0文件以防这些文件互相之间重叠。</p>

<p>一个压缩过程会合并选取的文件内容来产生一系列level-(L+1)文件。当前输出文件达到目标文件大小以后，我们切换到一个新level-(L+1)文件的产生过程。当前输出文件的键范围已经增长到足够重叠多于10个level-(L+2)文件以后，我们就切换到一个新的输出文件。前面最后的规则确保稍后的一个level-(L+1)文件的压缩不会从level-(L+2)选取太多的数据。(这一段基本没看懂。。。）</p>

<p>老的文件被丢弃，并且新文件会被添加到服务状态（serving state）。</p>

<p>对于某个特定level的压缩会在键范围内循环。再说的细一点儿，对于每个level L，我们记住level L上一次压缩的结束键（ending key），对于level L的下一次压缩，我们将会选取从那个结束键之后开始的第一个文件（如果不存在这样的文件，我们就绕回到键空间的开始位置）。</p>

<p>压缩会丢弃被复写（overwritten）过的值（values）。如果没有更高的level包含范围与当前键重叠的文件，压缩过程也会丢弃删除标记。</p>

<h1>计时（Timing）</h1>

<p>level-0的压缩将会从level-0读取多达4个长度为1MB的文件，并且从level-1在最差情况下会读取全部文件（10MB）。即，我们将会读14MB的文件，写14MB的文件。</p>

<p>除了这个特殊的level-0压缩之外，我们再看看其它层的压缩，我们需要从level L 选取一个2MB的文件，在最坏的情况下，这个文件会与level L+1 层的至少12个（原文这里用的是～12，查了半天不知道～在这里是什么意思，但是根据后面推断应该是最少的意思）文件重叠（其中的10个文件是因为level-(L+1) 的大小是level-L的十倍，另外最少两个文件是因为level-L被选取的文件的范围通常不会与level-L+1的文件的范围对齐)。因此，压缩将会读26MB，写26MB。假设磁盘IO的速度为100MB/s（对于现代驱动，大体上就在这个速度范围内），最坏情况下的压缩花费大约为0.5秒（（26MB + 26MB）/ 100MB/s = 0.5s）。</p>

<p>如果我们限制后台对一些小东西（something small）的写操作，比如只用全速100MB/s的10%，一个压缩将会消耗高达5秒的时间（（26MB + 26MB） / （100MB * 10%） = 5s）。如果用户正以10MB/s的速度在写，我们可以建立大量的level-0文件（～50 to hold the 5<em>10MB，前面这句我不知道该怎么翻才好，我是下，至少能建立50个文件，因为5s</em>10MB/s = 50MB，一次压缩时间为5s，速度为10MB/s，而本节开头提到level-0每个文件是1MB）。这可能会大幅增加读操作的代价，因为在每次读的时候需要合并更多的文件。</p>

<p>解决方案1：为了减轻这个问题，我们可能想要在level-0文件很大的时候增加日志文件切换的阈值(文档开头说默认是4MB）。尽管这么做有副作用，即这个阈值越大，我们将要需要更多的内存来保存相应的memtable。</p>

<p>解决方案2：我们可能希望在level-0的文件数目增长的时候人工降低写操作的速度。</p>

<p>解决方案3：我们设法减小大范围合并的代价。可能大多数level-0文件将会使它们的块在内存中处于不可压缩状态，那样的话我们就只需要担心合并迭代中的O（N）复杂度。</p>

<h1>文件数目（Number of files）</h1>

<p>并非总是创建2MB大小的文件，我们可以为更高的level创建更大的文件来减小文件数目，尽管是以更多的突发性压缩（bursty compations）为代价。还有另外一个选择，就是我们可以在多个目录中共享文件集合。</p>

<p>下面的计时显示的是2011年2月4号在<code>ext3</code>文件系统上做的实验，即在包含不同的文件数目的目录中做了100，000个打开文件的操作：</p>

<pre><code>    目录中的文件数目      打开一个文件的毫秒数

        1000                        9

       10000                       10

      100000                       16
</code></pre>

<p>所以，在现代文件系统上，甚至分片（sharding）都不是必须的？（道行太浅，表示没有看懂这句话。囧rz）</p>

<h1>恢复（Recovery）</h1>

<p>读取CURRENTWEN文件来找到最近提交的MANIFEST文件的名字</p>

<p>读取上面找到的MANIFEST文件（因为MANIFEST保存着每一个level的有序表的集合）</p>

<p>清空stable files（这个第一次出现在文档中，表示木有看懂。难道应该是sorted table的缩写？囧rz）</p>

<p>我们可以在这里打开全部的sstables，但是可能晚点打开更好。。。、</p>

<p>把日志块（log chunk）转换为一个新的level-0 sstable</p>

<p>开始按被恢复序列号（recovered sequencei#）把新的写操作引入到一个新的日志文件</p>

<h1>文件的垃圾收集（Garbage collection of files）</h1>

<p><code>DeleteObsoleteFiles()</code>在每次压缩的最后和每次恢复的最后被调用。它会找到数据库中所有文件的名字。它会删除所有的非当前日志文件。它会删除非引用自某个level的并且也不作为一个正在运行的压缩的输出文件的所有的表文件。</p>

<p>（全文完）</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/05/17/leveldbxiang-xi-wen-dang/">LevelDB详细文档</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-05-17T15:18:00+08:00" pubdate data-updated="true">May 17<span>th</span>, 2013</time>
        
         | <a href="/blog/2013/05/17/leveldbxiang-xi-wen-dang/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><em>本文档翻译自LevelDB的官方文档<a href="http://leveldb.googlecode.com/svn/trunk/doc/index.html">Detailed documentation</a>。为了保证严谨和可读性，有些地方在翻译的同时仍然在后面追加了对应的英文名称。有些部分也添加了我的个人理解。不妥的地方恳请大家留言斧正，不吝感激！</em></p>

<h1>LevelDB</h1>

<p><em>Jeff Dean, Sanjay Ghemawat</em></p>

<p>leveldb库提供了一个持久化的键-值存储（key value storage）。Keys和values可以是任意的字节数组。在键-值存储库中，keys按用户指定的比较函数（comparator fonction）进行排序。</p>

<h1>打开一个数据库（Opening A Database）</h1>

<p>每一个<code>leveldb</code>数据库都有一个名字，这个名字对应文件系统的一个目录。数据库所有个内容都被存放在这个目录下。紧接下来的例子说明了如何打开一个数据库（如果有必要的话就创建它）：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="cp">#include &lt;assert&gt;</span>
</span><span class='line'><span class="cp">#include &quot;leveldb/db.h&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="n">leveldb</span><span class="o">::</span><span class="n">DB</span><span class="o">*</span> <span class="n">db</span><span class="p">;</span>
</span><span class='line'><span class="n">leveldb</span><span class="o">::</span><span class="n">Options</span> <span class="n">options</span><span class="p">;</span>
</span><span class='line'><span class="n">options</span><span class="p">.</span><span class="n">create_if_missing</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'><span class="n">leveldb</span><span class="o">::</span><span class="n">Status</span> <span class="n">status</span> <span class="o">=</span> <span class="n">leveldb</span><span class="o">::</span><span class="n">DB</span><span class="o">::</span><span class="n">Open</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="s">&quot;/tmp/testdb&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">db</span><span class="p">);</span>
</span><span class='line'><span class="n">assert</span><span class="p">(</span><span class="n">status</span><span class="p">.</span><span class="n">ok</span><span class="p">());</span>
</span><span class='line'><span class="p">...</span>    
</span></code></pre></td></tr></table></div></figure>


<p>如果你想在这个数据库已经存在的前提下触发一个错误，把下面这行代码添加在<code>leveldb::DB::Open</code>调用之前：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">options</span><span class="p">.</span><span class="n">error_if_exists</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<h1>状态类型（Status）</h1>

<p>你可能已经注意到了上面代码中提到的<code>leveledb:Status</code>类型。leveldb库中绝大多数函数在运行中发生错误时都会返回这个类型的值。你可以通过检测结果是否为ok来打印相关的错误信息:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">leveldb</span><span class="o">::</span><span class="n">Status</span> <span class="n">s</span> <span class="o">=</span> <span class="p">...;</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">.</span><span class="n">ok</span><span class="p">())</span> <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">ToString</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<h1>关闭一个数据库(Closing A Database）</h1>

<p>当你完成了跟一个数据库相关的所有操作时，可以仅仅通过delete这个数据库对象来关闭这个数据库。比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="p">...</span> <span class="n">open</span> <span class="n">the</span> <span class="n">db</span> <span class="n">as</span> <span class="n">described</span> <span class="n">above</span> <span class="p">...</span>
</span><span class='line'><span class="p">...</span> <span class="k">do</span> <span class="n">something</span> <span class="n">with</span> <span class="n">db</span> <span class="p">...</span>
</span><span class='line'><span class="k">delete</span> <span class="n">db</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<h1>读和写（Reads And Writes）</h1>

<p>leveldb数据库提供了Put,Delete,和Get方法来修改/查询数据库。举个例子，接下来的代码就把跟key1对应的value挪到了跟key2对应的value中：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">value</span><span class="p">;</span>
</span><span class='line'><span class="n">leveldb</span><span class="o">::</span><span class="n">Status</span> <span class="n">s</span> <span class="o">=</span> <span class="n">db</span><span class="o">-&gt;</span><span class="n">Get</span><span class="p">(</span><span class="n">leveldb</span><span class="o">::</span><span class="n">ReadOptions</span><span class="p">(),</span> <span class="n">key1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">ok</span><span class="p">())</span> <span class="n">s</span> <span class="o">=</span> <span class="n">db</span><span class="o">-&gt;</span><span class="n">Put</span><span class="p">(</span><span class="n">leveldb</span><span class="o">::</span><span class="n">WriteOptions</span><span class="p">(),</span> <span class="n">key2</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">ok</span><span class="p">())</span> <span class="n">s</span> <span class="o">=</span> <span class="n">db</span><span class="o">-&gt;</span><span class="n">Delete</span><span class="p">(</span><span class="n">leveldb</span><span class="o">::</span><span class="n">WriteOptions</span><span class="p">(),</span> <span class="n">key1</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<h1>原子式更新（Atomic Updates）</h1>

<p>注意，(请看一眼上面的代码)如果在Put完key2但在删除key1之前进程死掉了，同样的value就会被存储在多个key下面。这个问题其实可以避免，就是使用<code>WriteBatch</code>类来自动对数据库施加一组更新操作：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="cp">#include &quot;leveldb/write_batch.h&quot;</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">value</span><span class="p">;</span>
</span><span class='line'><span class="n">leveldb</span><span class="o">::</span><span class="n">Status</span> <span class="n">s</span> <span class="o">=</span> <span class="n">db</span><span class="o">-&gt;</span><span class="n">Get</span><span class="p">(</span><span class="n">leveldb</span><span class="o">::</span><span class="n">ReadOptions</span><span class="p">(),</span> <span class="n">key1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">ok</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">leveldb</span><span class="o">::</span><span class="n">WriteBatch</span> <span class="n">batch</span><span class="p">;</span>
</span><span class='line'>  <span class="n">batch</span><span class="p">.</span><span class="n">Delete</span><span class="p">(</span><span class="n">key1</span><span class="p">);</span>
</span><span class='line'>  <span class="n">batch</span><span class="p">.</span><span class="n">Put</span><span class="p">(</span><span class="n">key2</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
</span><span class='line'>  <span class="n">s</span> <span class="o">=</span> <span class="n">db</span><span class="o">-&gt;</span><span class="n">Write</span><span class="p">(</span><span class="n">leveldb</span><span class="o">::</span><span class="n">WriteOptions</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">batch</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面这个<code>WriteBatch</code>类的对象<code>batch</code>包含一系列将会被施加到数据库上的编辑操作，这些编辑操作会按顺序被施加到数据库上。请注意，我们要在调用<code>Put</code>之前调用<code>Delete</code>，这么做的目的是如果key1跟key2的值（这里的值是指key1和key2本身的值，不是跟key1和key2对应的value的值）相同的话，我们最后也不会因为彻底删掉跟key1和key2对应的value而导致错误。（这里多补充两句，比如key1本身的值为name，它对应的value的值为Michael，假设新Put进来的key2的值也写成了name（这就是前面说的key1和key2的值相同，都是name），那么如果先put后delete的话，在Put之后Delete之前，数据库中就存在俩同样的键-值对(key:value)，即<code>name:Michael</code>，这时执行Delete操作的话，就会把key1:value和key2:value都给删掉，数据库中就彻底不存在name:Michael了，而这不是我们所希望的，所以要先Delete掉key1:value,然后Put进key2:value，这样即使key1和key2相同也不怕了）。
除了具备原子性之外，通过把大量的单个变更操作放到同一个<code>batch</code>对象中，<code>WriteBatch</code>类还能被用于批量更新（bulk updates）。</p>

<h1>同步写（Synchronus Writes)</h1>

<p>默认地，对leveldb数据库的每一次写操作都是异步的：write操作把要写的数据从进程push进操作系统就立马返回。从操作系统内存到底层持久化存储的转换是异步进行的。当然，同步(<code>sync</code>)标识也可以为某个特别的写操作打开，从而让这个写操作在数据被真正持久化存储以后再返回。（在遵循Posix标准的系统上，这个可以通过在写操作返回前调用<code>fsync(...)</code>或者<code>fdatasync(...)</code>或者<code>msync(..., MS_SYNC)</code> 来实现。）</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">leveldb</span><span class="o">::</span><span class="n">WriteOptions</span> <span class="n">write_options</span><span class="p">;</span>
</span><span class='line'><span class="n">write_options</span><span class="p">.</span><span class="n">sync</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'><span class="n">db</span><span class="o">-&gt;</span><span class="n">Put</span><span class="p">(</span><span class="n">write_options</span><span class="p">,</span> <span class="p">...);</span>
</span></code></pre></td></tr></table></div></figure>


<p>异步写操作通常比同步写操作快一千多倍。异步写操作的负面作用是，机器一旦宕掉可能会导致最后的少数更新被丢失。请注意，如果仅仅是写进程的一次挂掉（不是系统重新启动）则不会导致任何损失，因为即使当<code>sync</code>标识被设置为<code>false</code>时，一个更新操作在被认为完成之前就已经从进程内存被push到了操作系统内核。
异步写操作通常可以被安全地使用。举个栗子，当加载大量数据到数据库的时候，你可以在机器宕掉后，通过重启一次块加载（bulk load）操作来处理因为宕机而丢失的更新。在连续N次同步写操作的地方混合方案也是可行的，即，一次宕机事件中，被前一个运行（run）过程执行的最后一次同步写操作完成之后，块加载（bulk load）被重启一次。（同步写操作能够更新一个用来描述跟某次宕机相关的重启地点的标识。）
<code>WriteBatch</code>提供了异步写操作的一个替代选择。多个更新操作可能被置于同一个<code>WriteBatch</code>，并且通过一个同步写操作被一起执行（即，<code>write_option.sync</code>被设置为true）。通过这种方式，这次同步写操作的额外代价将会在它执行的这个批处理的全部写操作中被分期偿还。(对于最后一句话的理解，可以看看上一小节中的代码，db->Write()有俩参数，第一个参数决定这个Write是同步写操作还是异步写操作，第二个参数是个WriteBatch对象，它可以包含多个写入动作即Put操作，而且这个对象里包含的所有动作的执行是原子性的。)</p>

<h1>并发（Concurrency）</h1>

<p>一个数据库一次只能被一个进程打开。<code>leveldb</code>的实现要求使用来自操作系统的锁来阻止对数据库的滥用。在单进程中，同一个<code>leveldb::DB</code>对象可以被多个并发线程安全地共享。即，针对同一个数据库，在没有任何外部同步措施的前提下（leveldb实现本身将会自动去做所需要的同步过程），不同的线程可以写入迭代器或者获取迭代器或者调用<code>Get</code>方法。但是，其它的对象（比如Iterator和WriteBatch）可能需要外部的同步过程。如果两个线程共享一个这样的对象，这俩线程必须通过它们各自的加锁协议（locking protocol）来保护对这个对象的访问。更多的细节可以在公开的头文件中获得。</p>

<h1>迭代（Iteration）</h1>

<p>接下来的例子显示了如何打印数据库中所有的键-值对（key,value pair）：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">leveldb</span><span class="o">::</span><span class="n">Iterator</span><span class="o">*</span> <span class="n">it</span> <span class="o">=</span> <span class="n">db</span><span class="o">-&gt;</span><span class="n">NewIterator</span><span class="p">(</span><span class="n">leveldb</span><span class="o">::</span><span class="n">ReadOptions</span><span class="p">());</span>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">SeekToFirst</span><span class="p">();</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">Valid</span><span class="p">();</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">().</span><span class="n">ToString</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;: &quot;</span>  <span class="o">&lt;&lt;</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">().</span><span class="n">ToString</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">assert</span><span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">().</span><span class="n">ok</span><span class="p">());</span>  <span class="c1">// Check for any errors found during the scan</span>
</span><span class='line'><span class="k">delete</span> <span class="n">it</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>接下来的变形显示了如何只处理[start,limit)范围内的键：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">for</span> <span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">Seek</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
</span><span class='line'>       <span class="n">it</span><span class="o">-&gt;</span><span class="n">Valid</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">().</span><span class="n">ToString</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">limit</span><span class="p">;</span>
</span><span class='line'>       <span class="n">it</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>你也能够按倒序来处理各个项。（附加说明：倒序迭代可能比正序迭代有点慢。）</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">for</span> <span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">SeekToLast</span><span class="p">();</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">Valid</span><span class="p">();</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">Prev</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h1>快照（Snapshots）</h1>

<p>快照提供了键-值存储（key-value store）的全部状态的一致性的只读视图（read-only veews）。<code>ReadOptions::snapshot</code>（这是个指针）可能为非空（non-NULL），这表明一个读动作应该操作DB状态的某个版本。如果<code>ReadOptions::snapshot</code>为NULL，这个读操作将会操作当前状态的一个默认的（implicit）快照。
快照被<code>DB::GetSnapshot()</code>方法创建：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">leveldb</span><span class="o">::</span><span class="n">ReadOptions</span> <span class="n">options</span><span class="p">;</span>
</span><span class='line'><span class="n">options</span><span class="p">.</span><span class="n">snapshot</span> <span class="o">=</span> <span class="n">db</span><span class="o">-&gt;</span><span class="n">GetSnapshot</span><span class="p">();</span>
</span><span class='line'><span class="p">...</span> <span class="n">apply</span> <span class="n">some</span> <span class="n">updates</span> <span class="n">to</span> <span class="n">db</span> <span class="p">...</span>
</span><span class='line'><span class="n">leveldb</span><span class="o">::</span><span class="n">Iterator</span><span class="o">*</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">db</span><span class="o">-&gt;</span><span class="n">NewIterator</span><span class="p">(</span><span class="n">options</span><span class="p">);</span>
</span><span class='line'><span class="p">...</span> <span class="n">read</span> <span class="k">using</span> <span class="n">iter</span> <span class="n">to</span> <span class="n">view</span> <span class="n">the</span> <span class="n">state</span> <span class="n">when</span> <span class="n">the</span> <span class="n">snapshot</span> <span class="n">was</span> <span class="n">created</span> <span class="p">...</span>
</span><span class='line'><span class="k">delete</span> <span class="n">iter</span><span class="p">;</span>
</span><span class='line'><span class="n">db</span><span class="o">-&gt;</span><span class="n">ReleaseSnapshot</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">snapshot</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>请注意，当一个快照不再被需要的时候，应该通过<code>DB::ReleaseSnapshot</code>接口释放它。通过这种方式，实现可以丢弃被维护用来支持自那次快照以来的读操作的DB状态。</p>

<h1>切片（Slice）</h1>

<p>上面提到的<code>it-&gt;key()</code>和<code>it-&gt;value()</code>调用（参见 “迭代” 小节代码）的返回值是<code>leveldb::Slice</code>类型的实例。<code>Slice</code>是一个简单的结构体，这个结构体包含了一个长度（即<code>Slice::size_</code>)和一个指向外部字节数组的指针（即<code>Slice::data_</code>)。相对于返回一个<code>std::string</code>，返回一个<code>Slice</code>是一个更加省事儿（cheaper）的做法，因为这样我们就不需要拷贝潜在的巨大的键（keys）和值（values）了。另外，<code>leveldb</code>的方法不返回以空字符（&#8217;\0&#8217;）结尾的C风格的字符串，因为<code>leveldb</code>的键（keys）和值（values）中被允许包含&#8217;\0&#8217;（也就是<code>leveldb</code>中表示key和value的字符串的开头中间结尾都可以包含&#8217;\0&#8217;）。</p>

<p>C++ <code>string</code>和以空字符结尾的C风格的字符串可以很容易的被转换为一个<code>Slice</code>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">leveldb</span><span class="o">::</span><span class="n">Slice</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">&quot;hello&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span><span class="p">(</span><span class="s">&quot;world&quot;</span><span class="p">);</span>
</span><span class='line'><span class="n">leveldb</span><span class="o">::</span><span class="n">Slice</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">str</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>一个<code>Slice</code>也很容易被转换回一个C++ <code>string</code>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="nl">std:</span><span class="n">string</span> <span class="n">str</span> <span class="o">=</span> <span class="n">s1</span><span class="p">.</span><span class="n">ToString</span><span class="p">();</span>
</span><span class='line'><span class="n">assert</span><span class="p">(</span><span class="n">str</span> <span class="o">==</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">));</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用<code>Slice</code>的时候要小心，因为当一个<code>Slice</code>被使用的时候，将依赖调用者（caller）来确保<code>Slice</code>指向的外部字节数组保持存在状态（remains live）。举个栗子，下面的代码有bug:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">leveldb</span><span class="o">::</span><span class="n">Slice</span> <span class="n">slice</span><span class="p">;</span>
</span><span class='line'><span class="k">if</span> <span class="p">(...)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span> <span class="o">=</span> <span class="p">...;</span>
</span><span class='line'>  <span class="n">slice</span> <span class="o">=</span> <span class="n">str</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">Use</span><span class="p">(</span><span class="n">slice</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>当上面的<code>if</code>语句执行完毕（goes out of scope)的时候，<code>str</code>将被破坏（因为str是if语句块的局部变量），<code>slice</code>的备份存储（backing storage）也会消失。(多说两句，上面说了Slice里面有个指向外部字节数组的<code>Slice::data_</code>指针，也就是说Slice并不真正存储实际的数据，而是用一个指针指向它，这也是上面说的为什么返回一个Slice比返回一个std::string更加cheaper的做法，因为避免了数据拷贝，同时也是为什么在使用Slice的时候必须要careful的原因，因为如果不谨慎的话，很容易导致<code>Slice::data_</code>变成一个野指针。)</p>

<h1>比较器（Comparators）</h1>

<p>前面的例子用的都是针对key的默认的排序函数，这个默认的排序函数按字典序对字节进行排序。但是，你可以自己提供一个定制的比较器来打开一个数据库。举个栗子，假设每个数据库键（key）由两个数字构成，并且我们应该按照第一个数字来排序，当第一个数字相同的时候再按第二个数字排序。首先，定义一个继承自<code>leveldb::Comparator</code>的子类来表达下面的规则：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">TwoPartComparator</span> <span class="o">:</span> <span class="k">public</span> <span class="n">leveldb</span><span class="o">::</span><span class="n">Comparator</span> <span class="p">{</span>
</span><span class='line'>   <span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="c1">// Three-way comparison function:</span>
</span><span class='line'>    <span class="c1">//   if a &lt; b: negative result</span>
</span><span class='line'>    <span class="c1">//   if a &gt; b: positive result</span>
</span><span class='line'>    <span class="c1">//   else: zero result</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">Compare</span><span class="p">(</span><span class="k">const</span> <span class="n">leveldb</span><span class="o">::</span><span class="n">Slice</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">leveldb</span><span class="o">::</span><span class="n">Slice</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span><span class='line'>      <span class="kt">int</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">;</span>
</span><span class='line'>      <span class="n">ParseKey</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a2</span><span class="p">);</span>
</span><span class='line'>      <span class="n">ParseKey</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b2</span><span class="p">);</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="n">a1</span> <span class="o">&lt;</span> <span class="n">b1</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="n">a1</span> <span class="o">&gt;</span> <span class="n">b1</span><span class="p">)</span> <span class="k">return</span> <span class="o">+</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="n">a2</span> <span class="o">&lt;</span> <span class="n">b2</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="n">a2</span> <span class="o">&gt;</span> <span class="n">b2</span><span class="p">)</span> <span class="k">return</span> <span class="o">+</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Ignore the following methods for now:</span>
</span><span class='line'>    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">Name</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&quot;TwoPartComparator&quot;</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>    <span class="kt">void</span> <span class="n">FindShortestSeparator</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="n">leveldb</span><span class="o">::</span><span class="n">Slice</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="p">}</span>
</span><span class='line'>    <span class="kt">void</span> <span class="n">FindShortSuccessor</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">*</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>现在创建一个使用上面这个定制比较器的数据库：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">TwoPartComparator</span> <span class="n">cmp</span><span class="p">;</span>
</span><span class='line'><span class="n">leveldb</span><span class="o">::</span><span class="n">DB</span><span class="o">*</span> <span class="n">db</span><span class="p">;</span>
</span><span class='line'><span class="n">leveldb</span><span class="o">::</span><span class="n">Options</span> <span class="n">options</span><span class="p">;</span>
</span><span class='line'><span class="n">options</span><span class="p">.</span><span class="n">create_if_missing</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'><span class="n">options</span><span class="p">.</span><span class="n">comparator</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cmp</span><span class="p">;</span>
</span><span class='line'><span class="n">leveldb</span><span class="o">::</span><span class="n">Status</span> <span class="n">status</span> <span class="o">=</span> <span class="n">leveldb</span><span class="o">::</span><span class="n">DB</span><span class="o">::</span><span class="n">Open</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="s">&quot;/tmp/testdb&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">db</span><span class="p">);</span>
</span><span class='line'><span class="p">...</span>
</span></code></pre></td></tr></table></div></figure>


<p><em>向后兼容性（Backwards compatibility）</em></p>

<p>在数据库被创建的时候,比较器中的<code>Name</code>方法的返回值会被附加到数据库上，并且这个数据库在后续每次被打开的时候，这个返回值还会被检查。如果这个name改变了，<code>leveldb::DB::Open</code>调用将会失败。因此，当且仅当新的键格式（key format）和比较函数与现存数据库不兼容的时候，才能改变这个name，并且也可以丢弃所有现存数据库的内容。</p>

<p>但是，你仍然可以按已经制定的计划一点点地渐进演进你的键格式（key format）。举个栗子，你可以在每个键（key）的末尾存储一个版本号（对于大多数应用会牺牲一个字节）。当你希望转换到一个新的键格式(key format)的时候（比如，添加一个可选的第三部分到通过<code>TwoPartComparator</code>处理的keys上），（a)保持同样的比较器name（b)为新的keys递增版本号（c)改变比较器函数以让它使用在keys中发现的版本号来决定如何解释它们。</p>

<h1>性能（Performance）</h1>

<p>性能可以通过改变定义在<code>include/leveldb/options.h</code>中的各个类型的默认值来进行调整。</p>

<p><em>块大小（Block size）</em></p>

<p><code>leveldb</code>把相邻的键（keys）组织到同一个块（block）中，并且这样的一个块（block）是转移进/转移出（transfer to and from）持久化存储（persistent storage）的基本单元。默认的块大小大约为4096个非压缩字节。大多数针对整个数据库的内容做大量扫描（bulk scan）的应用程序可能希望增大这个值。而针对一些小数据（small values）进行大量“点读”（原文是point reads，我觉得应该是每次只访问这些小数据的一小部分）的应用程序可能希望切换到一个更小的块（如果切换到更小的块后性能测试能够表明性能改善的话）。块大小小于1K字节或者大于几M字节都不会得到更多的好处。也请注意，使用更大的块大小的时候，压缩（compression）将会变得更加有效果。</p>

<p><em>压缩（Compression）</em></p>

<p>每一个块在被写入持久化存储（persistent storage）的时候，都会被单独进行压缩。压缩功能默认是开启的，因为默认的压缩方法非常的快，而且，针对不可进行压缩的数据，压缩功能会自动失效。极少数情况下，应用程序可能想要完全关闭压缩功能，但是仅当基准测试(benchmark)能够表明这样做能改善性能的时候才应该这么做：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">leveldb</span><span class="o">::</span><span class="n">Options</span> <span class="n">options</span><span class="p">;</span>
</span><span class='line'><span class="n">options</span><span class="p">.</span><span class="n">compression</span> <span class="o">=</span> <span class="n">leveldb</span><span class="o">::</span><span class="n">kNoCompression</span><span class="p">;</span>
</span><span class='line'><span class="p">...</span> <span class="n">leveldb</span><span class="o">::</span><span class="n">DB</span><span class="o">::</span><span class="n">Open</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="p">...)</span> <span class="p">....</span>
</span></code></pre></td></tr></table></div></figure>


<p><em>缓存（Cache）</em></p>

<p>数据库的内容被存储在文件系统的一组文件中，并且每个文件存储一系列被压缩过的块。如果<code>options.cache</code>不为空（non-NULL），它被用来缓存那些频繁被用到的不能进行压缩的块内容。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="cp">#include &quot;leveldb/cache.h&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="n">leveldb</span><span class="o">::</span><span class="n">Options</span> <span class="n">options</span><span class="p">;</span>
</span><span class='line'><span class="n">options</span><span class="p">.</span><span class="n">cache</span> <span class="o">=</span> <span class="n">leveldb</span><span class="o">::</span><span class="n">NewLRUCache</span><span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="mi">1048576</span><span class="p">);</span>  <span class="c1">// 100MB cache</span>
</span><span class='line'><span class="n">leveldb</span><span class="o">::</span><span class="n">DB</span><span class="o">*</span> <span class="n">db</span><span class="p">;</span>
</span><span class='line'><span class="n">leveldb</span><span class="o">::</span><span class="n">DB</span><span class="o">::</span><span class="n">Open</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">db</span><span class="p">);</span>
</span><span class='line'><span class="p">...</span> <span class="n">use</span> <span class="n">the</span> <span class="n">db</span> <span class="p">...</span>
</span><span class='line'><span class="k">delete</span> <span class="n">db</span>
</span><span class='line'><span class="k">delete</span> <span class="n">options</span><span class="p">.</span><span class="n">cache</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>请注意，缓存包含不能被压缩的数据，因此它应该根据应用层的数据量来调整大小，不能因为压缩而缩减自己的大小。（对于压缩块的缓存被留给了操作系统的缓冲器高速缓冲存储器（buffer cache），或者任何由客户端提供的定制的<code>Env</code>实现。）</p>

<p>当执行一个大块读操作（a bulk read）的时候，应用程序可能希望取消缓存，这样被该读操作处理的数据就不会在最后取代绝大部分的缓存内容。可以使用一个per-iterator操作(这个地方我找不到一个恰当的词来翻译，结合下面的程序可以很容易神会，就是创建一个迭代器来遍历要操作的数据，关键是创建这个迭代器的时候把相关的options的fill_cache属性设置为false）达到这个目的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">leveldb</span><span class="o">::</span><span class="n">ReadOptions</span> <span class="n">options</span><span class="p">;</span>
</span><span class='line'><span class="n">options</span><span class="p">.</span><span class="n">fill_cache</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
</span><span class='line'><span class="n">leveldb</span><span class="o">::</span><span class="n">Iterator</span><span class="o">*</span> <span class="n">it</span> <span class="o">=</span> <span class="n">db</span><span class="o">-&gt;</span><span class="n">NewIterator</span><span class="p">(</span><span class="n">options</span><span class="p">);</span>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">SeekToFirst</span><span class="p">();</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">Valid</span><span class="p">();</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><em>键布局（Key Layout）</em></p>

<p>请注意，磁盘迁移（transfer）和缓存数据的基本单位是一个块（block）。按数据库排序算法排序后，相邻的键（keys）将通常被安置在同一个块中。因此，应用程序能够通过把那些被访问的键放在一起或者把那些频繁被用到的键放到键空间（key space）的一个单独的区域来改善性能。</p>

<p>举个栗子，假设我们正在<code>leveldb</code>基础上来实现一个简单的文件系统（file system）。我们可能希望存储的每个项（entries）的类型是下面的样子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">filename</span> <span class="o">-&gt;</span> <span class="n">permission</span><span class="o">-</span><span class="n">bits</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">list</span> <span class="n">of</span> <span class="n">file_block_ids</span>
</span><span class='line'><span class="n">file_block_id</span> <span class="o">-&gt;</span> <span class="n">data</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们可能想要给<code>filename</code>键设置一个单字母长度的前缀（比如&#8217;/&#8217;），给<code>file_block_id</code>键设置一个不同的同样是单字母长度的前缀（比如&#8217;0&#8217;），这样的话，仅仅对元数据（metadata）进行的全面扫描就不用强迫我们去获取和缓存大块的文件内容了。</p>

<p><em>过滤器（Filters）</em></p>

<p>鉴于<code>leveldb</code>数据在磁盘上的组织方式，一个单独的<code>Get()</code>调用可能会涉及多次磁盘读取。可选的<code>FilterPolicy</code>机制能够被用来显著地减少磁盘读取次数。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">leveldb</span><span class="o">::</span><span class="n">Options</span> <span class="n">options</span><span class="p">;</span>
</span><span class='line'><span class="n">options</span><span class="p">.</span><span class="n">filter_policy</span> <span class="o">=</span> <span class="n">NewBloomFilterPolicy</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</span><span class='line'><span class="n">leveldb</span><span class="o">::</span><span class="n">DB</span><span class="o">*</span> <span class="n">db</span><span class="p">;</span>
</span><span class='line'><span class="n">leveldb</span><span class="o">::</span><span class="n">DB</span><span class="o">::</span><span class="n">Open</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="s">&quot;/tmp/testdb&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">db</span><span class="p">);</span>
</span><span class='line'><span class="p">...</span> <span class="n">use</span> <span class="n">the</span> <span class="n">database</span> <span class="p">...</span>
</span><span class='line'><span class="k">delete</span> <span class="n">db</span><span class="p">;</span>
</span><span class='line'><span class="k">delete</span> <span class="n">options</span><span class="p">.</span><span class="n">filter_policy</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>前面的代码把基于布隆过滤器（<a href="http://en.wikipedia.org/wiki/Bloom_filter">Bloom filter</a>）的过滤策略与数据库db关联起来了。基于布隆过滤器的过滤操作依靠的是在内存中为每个键（key）保持的一定数目的数据位（在上面这个例子中每个键用了10个比特，因为我们传给<code>NewBloomFilterPolicy</code>的参数就是10）。这个过滤器将会把<code>Get()</code>调用所涉及的不必要的磁盘读取次数减小一个大约100左右的因子。增加为每个键在内存中保持的数据位的个数将会进一步大幅减小不必要的磁盘读取次数，当然这要以更多的内存使用为代价。我们推荐那些工作集（working set）不能完全放进内存并且要做大量随机读取操作的应用程序都设置一个过滤策略。</p>

<p>如果你在使用一个定制的比较器，你应该确保你正在使用的过滤策略跟你的比较器是兼容的。举个栗子，考虑这样的一个比较器，当比较键（keys）的时候它会忽略尾随的空格（trailing space）。<code>NewBloomFilterPolicy</code>一定不能跟这样的一个比较器一块使用。那该怎么做呢？应用程序应该也提供一个定制的过滤器策略，这个过滤器策略也要忽略尾随空格（trailing space）。比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">CustomFilterPolicy</span> <span class="o">:</span> <span class="k">public</span> <span class="n">leveldb</span><span class="o">::</span><span class="n">FilterPolicy</span> <span class="p">{</span>
</span><span class='line'>   <span class="k">private</span><span class="o">:</span>
</span><span class='line'>    <span class="n">FilterPolicy</span><span class="o">*</span> <span class="n">builtin_policy_</span><span class="p">;</span>
</span><span class='line'>   <span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="n">CustomFilterPolicy</span><span class="p">()</span> <span class="o">:</span> <span class="n">builtin_policy_</span><span class="p">(</span><span class="n">NewBloomFilterPolicy</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span> <span class="p">{</span> <span class="p">}</span>
</span><span class='line'>    <span class="o">~</span><span class="n">CustomFilterPolicy</span><span class="p">()</span> <span class="p">{</span> <span class="k">delete</span> <span class="n">builtin_policy_</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">Name</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&quot;IgnoreTrailingSpacesFilter&quot;</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">void</span> <span class="n">CreateFilter</span><span class="p">(</span><span class="k">const</span> <span class="n">Slice</span><span class="o">*</span> <span class="n">keys</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">*</span> <span class="n">dst</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span><span class='line'>      <span class="c1">// Use builtin bloom filter code after removing trailing spaces</span>
</span><span class='line'>      <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Slice</span><span class="o">&gt;</span> <span class="n">trimmed</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
</span><span class='line'>      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">trimmed</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">RemoveTrailingSpaces</span><span class="p">(</span><span class="n">keys</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">builtin_policy_</span><span class="o">-&gt;</span><span class="n">CreateFilter</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trimmed</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">n</span><span class="p">,</span> <span class="n">dst</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">bool</span> <span class="n">KeyMayMatch</span><span class="p">(</span><span class="k">const</span> <span class="n">Slice</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">,</span> <span class="k">const</span> <span class="n">Slice</span><span class="o">&amp;</span> <span class="n">filter</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span><span class='line'>      <span class="c1">// Use builtin bloom filter code after removing trailing spaces</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">builtin_policy_</span><span class="o">-&gt;</span><span class="n">KeyMayMatch</span><span class="p">(</span><span class="n">RemoveTrailingSpaces</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="n">filter</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>更高级的应用程序可能会提供一个不使用布隆过滤器而是一些其它的过滤策略来对一组键进行摘要（summarizing）。详见<code>leveldb/filter_policy.h</code>。</p>

<h1>校验和（Checksums）</h1>

<p><code>leveldb</code>把checksums与它存储在文件系统中的所有数据关联了起来。有两个独立的控制手段表明了在进行checksum验证的时候可以多么激进：</p>

<p>1.<code>ReadOptions::verify_checksums</code>可能被设置为true来对从文件系统中读取的所有数据强制进行checksum验证，而不是针对某一次读动作进行checksum验证。默认地，这种验证不会发生。</p>

<p>2.<code>Options::paranoid_checks</code>可能会在打开一个数据库之前被设置为true，这样可以让数据库实现（database implementation）一旦检测到内部错误就立即引发一个错误。错误可能会在数据库被打开的时候被引发，或者以后被另外的数据库操作引发，这取决于数据库的哪个部分发生了错误。paranoid checking默认是关闭的，这么做是为了当数据库的一部分持久化存储被损坏的时候，数据库仍然可以继续被使用。</p>

<p>如果一个数据库损坏了（当paranoid checking被打开的时候它可能就不能被打开了），<code>leveldb::RepairDB</code>函数可以被用来恢复尽可能多的数据。</p>

<h1>近似大小（Approximate Size）</h1>

<p><code>GetApproximateSizes</code>方法能被用来获取被一个或多个键范围（key ranges）使用的文件系统空间的近似字节数目。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">leveldb</span><span class="o">::</span><span class="n">Range</span> <span class="n">ranges</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span><span class='line'><span class="n">ranges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">leveldb</span><span class="o">::</span><span class="n">Range</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="s">&quot;c&quot;</span><span class="p">);</span>
</span><span class='line'><span class="n">ranges</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">leveldb</span><span class="o">::</span><span class="n">Range</span><span class="p">(</span><span class="s">&quot;x&quot;</span><span class="p">,</span> <span class="s">&quot;z&quot;</span><span class="p">);</span>
</span><span class='line'><span class="n">uint64_t</span> <span class="n">sizes</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span><span class='line'><span class="n">leveldb</span><span class="o">::</span><span class="n">Status</span> <span class="n">s</span> <span class="o">=</span> <span class="n">db</span><span class="o">-&gt;</span><span class="n">GetApproximateSizes</span><span class="p">(</span><span class="n">ranges</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">sizes</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>前面的调用将会把<code>size[0]</code>设置为被键范围<code>[a..c)</code>使用的文件系统的近似字节数目，把&#8217;size[1]<code>设置为被键范围</code>[x..z)`使用的近似字节数目。</p>

<h1>环境（Environment）</h1>

<p>被<code>leveldb</code>实现发布的所有的文件操作（还有其它的操作系统调用）通过一个<code>level::Env</code>对象被路由。复杂精致的客户端可能希望提供它们自己的<code>Env</code>实现来获得更好的控制。比如，一个应用程序可能会在文件IO路径上引入人工延迟来限制<code>leveldb</code>对系统上其它活动(activities)的影响。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">SlowEnv</span> <span class="o">:</span> <span class="k">public</span> <span class="n">leveldb</span><span class="o">::</span><span class="n">Env</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">..</span> <span class="n">implementation</span> <span class="n">of</span> <span class="n">the</span> <span class="n">Env</span> <span class="n">interface</span> <span class="p">...</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="n">SlowEnv</span> <span class="n">env</span><span class="p">;</span>
</span><span class='line'><span class="n">leveldb</span><span class="o">::</span><span class="n">Options</span> <span class="n">options</span><span class="p">;</span>
</span><span class='line'><span class="n">options</span><span class="p">.</span><span class="n">env</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">env</span><span class="p">;</span>
</span><span class='line'><span class="n">Status</span> <span class="n">s</span> <span class="o">=</span> <span class="n">leveldb</span><span class="o">::</span><span class="n">DB</span><span class="o">::</span><span class="n">Open</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="p">...);</span>
</span></code></pre></td></tr></table></div></figure>


<h1>移植（Porting）</h1>

<p><code>leveldb</code>可以通过提供由<code>leveldb/port/port.h</code>导出的types/methods/functions的相关平台详细实现而被移植到一个新的平台上。详见<code>leveldb/port/port_example.h</code>。
另外，新平台可能需要一个新的默认的<code>leveldb::Env</code>实现。详见<code>leveldb/util/env_posix.h</code>里面的例子。</p>

<h1>其它信息（Other Information）</h1>

<p>有关<code>leveldb</code>实现的细节请见下面的文档(后续会全部翻译)：</p>

<p> <a href="http://leveldb.googlecode.com/svn/trunk/doc/impl.html">Implementation notes</a></p>

<p> <a href="http://leveldb.googlecode.com/svn/trunk/doc/table_format.txt">Formait of an immutable Table file</a></p>

<p> <a href="http://leveldb.googlecode.com/svn/trunk/doc/log_format.txt">Format of a log file</a></p>

<p>（全文完）</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/01/12/hai-liang-shu-ju-cun-chu-xi-lie-zhi-ha-xi/">海量数据存储系列之哈希</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-01-12T18:23:00+08:00" pubdate data-updated="true">Jan 12<span>th</span>, 2013</time>
        
         | <a href="/blog/2013/01/12/hai-liang-shu-ju-cun-chu-xi-lie-zhi-ha-xi/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>数据存储起来，为毛要存储起来，肯定为了以后用来查询，也就是搜索，既然查询，当然希望查询速度越快越好了，时间复杂度是O（1）最理想了，哈希表就能办到。当然天下木有免费的午餐，速度是靠牺牲空间来得到的，也就是常说的“空间换时间”。人们后来感觉哈希也忒浪费空间了，于是布隆过滤器应运而生，查询很快的前提下进一步节省空间，比哈希更加强大，但是要牺牲正确率。（说句题外话，如果留心，会发现这个自然界真的好公平的，不管你想得到什么，肯定要首先作出牺牲，或者以后作出牺牲，这个“牺牲”是必须的。很多人比较在乎得到之前的牺牲，而对延期交付的牺牲不是太在乎。这算自然界其中一种形式的”能量守恒“吧。感觉万事皆顺从道。一个感触。）</p>

<p>我这里只说用“链地址法”实现的哈希表，因为STL的哈希表是用这种方法实现的，JAVA重的hashmap也是用这种方法实现的，Redis里面的哈希表也是用这种方式实现的。待续。。。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/01/12/hai-liang-shu-ju-cun-chu-xi-lie-zhi-kai-pian-jie-shao/">海量数据存储系列之开篇介绍</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-01-12T17:46:00+08:00" pubdate data-updated="true">Jan 12<span>th</span>, 2013</time>
        
         | <a href="/blog/2013/01/12/hai-liang-shu-ju-cun-chu-xi-lie-zhi-kai-pian-jie-shao/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>现在大数据火的一塌糊涂，自称不懂技术的马云退休演讲都提到，移动互联网还没弄明白，大数据时代又来了。给这个系列取名字时我挺犹豫的，要不要用“海量”俩字，想用“大量”但感觉不够准确，“海量”又觉得有点大了，不管了。</p>

<p>这个系列，我打算总结一下跟海量数据存储有关的数据结构，哈希（hash）、位图（bitmap）、布隆过滤器（bloom filter）等。</p>

<p>如果谁觉得我有错误或者不准确的地方，恳请您给我斧正。拜谢ORL</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/12/17/arpqi-pian-de-shi-xian/">ARP欺骗的实现</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-12-17T22:06:00+08:00" pubdate data-updated="true">Dec 17<span>th</span>, 2012</time>
        
         | <a href="/blog/2012/12/17/arpqi-pian-de-shi-xian/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>ARP欺骗是用处很大的一个技术，我们的路由器整天在欺骗我们的PC，没有这个欺骗我们就不能上网。</p>

<p>先稍微说下我们每天经历的ARP欺骗，比如早上开路由器开PC，我们上Google，PC在发送IP包之前（假设Google的IP为173.194.72.94，当然事先要先通过DNS服务器获取Google的IP，这个不多谈）要先这个IP包装配为以太网帧，所以PC必须要知道Google服务器端MAC，才能填充好以太网帧。要想知道Google的MAC地址，我们的PC就要发送ARP广播请求，跟你一个局域网里的所有以太网设备都能收到这个请求，你希望有人告诉自己与173.194.72.94匹配的MAC地址是多少，因为我们的PC跟Google的服务器不在一个局域网里，所以Google服务器没法收到你的ARP请求，但是如果这个局域网中有其他PC知道的话，它收到这个请求就会给你发送ARP应答告诉你，如果没人知道怎么办？只能靠骗了！这个骗子就是路由器，这也是它的一个职责。路由器用自己的MAC地址冒充Google服务器的MAC地址，给你发ARP应答糊弄你，你收到应答后喜得不行，然后把所有帧都发给了路由器。下面我们就看路由器时怎么欺骗你的。</p>

<p>路由器能捕捉到这个局域网里广播帧，假设路由器捕捉到的PC的ARP广播帧写成十六进制为：</p>

<pre><code>    FFFFFFFFFFFFCE1A8206DA0708060001080006040001CE1A820C6B07C0A8127A000000000000C0A8127B00000B00482A00000D00000060FB5EFB61FB
</code></pre>

<p>按以太网帧结构把这个帧分解后为：</p>

<pre><code>    FFFFFFFFFFFF---目的MAC，因为是广播帧，所以MAC地址全为1
    CE1A8206DA07---源MAC，这里就是你PC的MAC
    0806—---帧类型（以太网帧都是这个数）
    0001----硬件类型（以太网帧都是这个数）
    0800----协议类型（以太网帧都是这个数）
    06----硬件地址长度（以太网帧都是这个数）
    04----协议地址长度（以太网帧都是这个数）
    0001—---操作字段（0001为ARP请求，0002为ARP应答）
    CE1A820C6B07---源mac，还是你的PC的MAC地址
    C0A8127A-------源IP地址，就是你的PC的ip
    000000000000---目的mac，因为不知道，所以把这6个字节胡乱填充一下就好
    ADC2485E-------目的ip，就是Google的IP
    00000B00482A00000D00000060FB5EFB61FB---这18个字节都是填充，就是为了凑够以太网帧最小长度60字节
</code></pre>

<p>然后路由器收到PC的ARP广播请求后就给你发送应答，这个应答帧为：</p>

<pre><code>    CE1A8206DA07000A3501FA1708060001080006040002000A3501FA17ADC2485ECE1A8206DA07C0A8127A00000B00482A00000D00000060FB5EFB61FB
</code></pre>

<p>按照以太网帧格式拆分后为：</p>

<pre><code>    CE1A8206DA07---目的MAC，ARP应答不是广播帧，它直接把PC的MAC地址当成目的MAC
    000A3501FA17---源MAC，这个是冒牌的，值本来该是Google服务器的MAC地址，但是这里路由器用自己的MAC来冒充
    0806—---帧类型（以太网帧都是这个数）
    0001----硬件类型（以太网帧都是这个数）
    0800----协议类型（以太网帧都是这个数）
    06----硬件地址长度（以太网帧都是这个数）
    04----协议地址长度（以太网帧都是这个数）
    0002—---操作字段（1为ARP请求，2为ARP应答）
    000A3501FA17---源MAC
    ADC2485E-------源IP地址，这个必须是ARP请求中的那个目的IP，也就是Google的IP。这个是重中之重，我的代码在
            这犯过错误，如果PC收到应答后检查这个IP发现与自己请求的目的IP不一样，心说，莫名其妙，我
            什么时候请求这个IP的MAC地址了？滚！它就会果断抛弃这个帧，然后继续请求，
            谁知道Google的MAC地址呀！！！
    CE1A8206DA07---目的mac也就是PC的MAC地址
    C0A8127A-------目的ip，就是PC的IP
    00000B00482A00000D00000060FB5EFB61FB---这18个字节都是填充，为了凑够以太网帧最小长度60字节，这个应答完全
                        照抄了请求的填充，这些数都无所谓。
</code></pre>

<p>PC在收到这个帧后，就真以为那个MAC地址是Google的，然后就把帧一股脑全发给路由器了。</p>

<p>然后你就可以上Google了。
然后大家一起来拍砖！</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/4/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/blog/page/2/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>最新评论</h1>
  <script type="text/javascript" src="http://chienlung.disqus.com/recent_comments_widget.js?num_items=5&hide_avatars=0&avatar_size=32&excerpt_length=200"></script>
</section>






  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - Chienlung -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'Chienlung';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
