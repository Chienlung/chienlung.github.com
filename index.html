<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"chielungcheung.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="programatrix">
<meta property="og:url" content="https://chielungcheung.github.io/index.html">
<meta property="og:site_name" content="programatrix">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Chienlung Cheung">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://chielungcheung.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>programatrix</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-177829579-1"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-177829579-1');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">programatrix</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Be the change you wish to see in the world.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://chielungcheung.github.io/2020/09/22/leveldb-annotations-2-log-read-write/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chienlung Cheung">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="programatrix">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/22/leveldb-annotations-2-log-read-write/" class="post-title-link" itemprop="url">Leveldb 源码详解系列之二: log 读写</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-22 19:16:28" itemprop="dateCreated datePublished" datetime="2020-09-22T19:16:28+00:00">2020-09-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-25 06:37:30" itemprop="dateModified" datetime="2020-09-25T06:37:30+00:00">2020-09-25</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2020/09/22/leveldb-annotations-2-log-read-write/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/09/22/leveldb-annotations-2-log-read-write/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!-- toc -->

<ul>
<li><a href="#log-%E6%96%87%E4%BB%B6%E7%AE%80%E4%BB%8B">log 文件简介</a></li>
<li><a href="#%E8%AF%BB-log">读 log</a><ul>
<li><a href="#%E6%A0%B8%E5%BF%83%E6%96%87%E4%BB%B6%E4%B8%8E%E6%A0%B8%E5%BF%83%E7%B1%BB">核心文件与核心类</a></li>
<li><a href="#reader-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95">Reader 构造方法</a></li>
<li><a href="#reader-%E8%AF%BB%E5%8F%96%E6%96%B9%E6%B3%95">Reader 读取方法</a></li>
</ul>
</li>
<li><a href="#%E5%86%99-log">写 log</a><ul>
<li><a href="#%E6%A0%B8%E5%BF%83%E6%96%87%E4%BB%B6%E4%B8%8E%E6%A0%B8%E5%BF%83%E7%B1%BB-1">核心文件与核心类</a></li>
<li><a href="#writer-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95">Writer 构造方法</a></li>
<li><a href="#writer-%E5%86%99%E6%96%B9%E6%B3%95">Writer 写方法</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<h1><span id="log-文件简介">log 文件简介</span></h1><p>我们先简单回顾下 log 文件相关的基础知识点, 具体请见 <a href="/2020/09/11/leveldb-annotations-1-interfaces-and-files/" title="Leveldb 原理详解系列之一: 接口与文件">Leveldb 原理详解系列之一: 接口与文件</a>.</p>
<p>log 文件(*.log)保存着数据库最近一系列更新操作, 它相当于 leveldb 的 WAL(<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Write-ahead_logging">write-ahead logging</a>). 当前在用的 log 文件内容同时也会被记录到一个内存数据结构中(即 <code>memtable</code> ). 每个更新操作都被追加到当前的 log 文件和 <code>memtable</code> 中. 当 log 文件大小达到一个预定义的大小时(默认大约 4MB), 这个 log 文件对应的 <code>memtable</code> 就会被转换为一个 sorted table 文件落盘然后一个新的 log 文件就会被创建以保存未来的更新操作. </p>
<p>log 文件内容是一系列 blocks, 每个 block 大小为 32KB(有时候最后一个 block 可能装不满). 每个 block 由一系列 records 构成, 具体定义如下(熟悉编译原理的应该对下述写法不陌生): </p>
<pre><code>// 即 0 或多个 records, 0 或 1 个 trailer.
// 最大为 32768 字节.
block := record* trailer?
record :=
  // 下面提到的 type 和 data[] 的 crc32c 校验和, 小端字节序
  checksum: uint32
  // 下面的 data[] 的长度, 小端字节序
  length: uint16
  // 类型, FULL、FIRST、MIDDLE、LAST 取值之一
  type: uint8
  // 用户数据
  data: uint8[length]</code></pre>
<p>type 取值如下:</p>
<pre><code>FULL == 1
FIRST == 2
MIDDLE == 3
LAST == 4</code></pre>
<p>FULL 类型的 record 包含了一个完整的用户 record 的内容. </p>
<p>FIRST、MIDDLE、LAST 这三个类型用于被分割成多个 fragments 的用户 record. FIRST 表示某个用户 record 的第一个 fragment, LAST 表示某个用户 record 的最后一个 fragment, MIDDLE 表示某个用户 record 的中间 fragments. </p>
<p>如果当前 block 恰好剩余 7 个字节(正好可以容纳 record 中的 checksum + length + type), 并且一个新的非 0 长度的 record 要被写入, 那么 writer 必须在此处写入一个 FIRST 类型的 record(但是 length 字段值为 0, data 字段为空. 用户数据 data 部分需要写入下个 block, 而且下个 block 起始还是要写入一个 header 不过其 type 为 middle)来填满该 block 尾部的 7 个字节, 然后在接下来的 blocks 中写入全部用户数据.</p>
<h1><span id="读-log">读 log</span></h1><p>下面分析读 log 相关的类和方法.</p>
<h2><span id="核心文件与核心类">核心文件与核心类</span></h2><p>与读 log 相关的代码定义在下面两个文件中:</p>
<pre><code>db/log_reader.h
db/log_reader.cc</code></pre>
<p>核心类为 <code>class leveldb::log::Reader</code>. 下面针对这个类核心方法进行分析.</p>
<h2><span id="reader-构造方法">Reader 构造方法</span></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 Reader 来从 file 中读取和解析 records, </span></span><br><span class="line"><span class="comment">// 读取的第一个 record 的起始位置位于文件 initial_offset 或其之后的物理地址. </span></span><br><span class="line"><span class="comment">// 如果 reporter 不为空, 则在检测到数据损坏时汇报要丢弃的数据估计大小. </span></span><br><span class="line"><span class="comment">// 如果 checksum 为 true, 则在可行的条件比对校验和. </span></span><br><span class="line"><span class="comment">// 注意, file 和 reporter 的生命期不能短于 Reader 对象. </span></span><br><span class="line">Reader(SequentialFile* file, Reporter* reporter, <span class="keyword">bool</span> checksum, <span class="keyword">uint64_t</span> initial_offset)</span><br></pre></td></tr></table></figure>

<h2><span id="reader-读取方法">Reader 读取方法</span></h2><p><code>bool ReadRecord(Slice* record, std::string* scratch)</code> 方法负责从 log 文件读取内容并反序列化为 Record. 该方法会在 db 的 <code>Open</code> 方法中调用, 负责将磁盘上的 log 文件转换为内存中 memtable. 其它数据库恢复场景也会用到该方法.</p>
<p>所做的事情, 概括地讲就是从文件读取下一个 record 到 <code>*record</code> 中. 如果读取成功, 返回 true; 遇到文件尾返回 false. 如果当前读取的 record 没有被分片, 那就用不到 <code>*scratch</code> 参数来为 <code>*record</code> 做底层存储了; 其它情况需要借助 <code>*scratch</code> 来拼装分片的 record data 部分, 最后封装为一个 Slice 赋值给 <code>*record</code>. </p>
<p>具体处理流程见下面详细注释:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Reader::ReadRecord</span><span class="params">(Slice* record, <span class="built_in">std</span>::<span class="built_in">string</span>* scratch)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// last_record_offset_ 表示上一次调用 ReadRecord 方法返回的</span></span><br><span class="line">  <span class="comment">// record 的起始偏移量, 注意这个 record 是逻辑的. </span></span><br><span class="line">  <span class="comment">// initial_offset_ 表示用户创建 Reader 时指定的在文件中寻找第一个 record 的起始地址.</span></span><br><span class="line">  <span class="comment">// 如果条件成立, 表示当前方法是首次被调用.</span></span><br><span class="line">  <span class="keyword">if</span> (last_record_offset_ &lt; initial_offset_) &#123;</span><br><span class="line">    <span class="comment">// 跳到我们要读取的第一个 block 起始位置</span></span><br><span class="line">    <span class="keyword">if</span> (!SkipToInitialBlock()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  scratch-&gt;clear();</span><br><span class="line">  record-&gt;clear();</span><br><span class="line">  <span class="comment">// 指示正在处理的 record 是否被分片了, </span></span><br><span class="line">  <span class="comment">// 除非逻辑 record 对应的物理 record 类型是 full, 否则就是被分片了.</span></span><br><span class="line">  <span class="keyword">bool</span> in_fragmented_record = <span class="literal">false</span>; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 记录我们正在读取的逻辑 record 的起始偏移量. 初值为 0 无实际意义仅为编译器不发警告. </span></span><br><span class="line">  <span class="comment">// 为啥叫逻辑 record 呢？</span></span><br><span class="line">  <span class="comment">// 因为 block 大小限制, 所以 record 可能被分成多个分片(fragment). </span></span><br><span class="line">  <span class="comment">// 我们管 fragment 叫物理 record, 一个或多个物理 record 构成一个逻辑 record. </span></span><br><span class="line">  <span class="keyword">uint64_t</span> prospective_record_offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  Slice fragment;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 从文件读取一个物理 record 并将其 data 部分保存到 fragment, </span></span><br><span class="line">    <span class="comment">// 同时返回该 record 的 type.</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> record_type = ReadPhysicalRecord(&amp;fragment);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算返回的当前 record 在 log file 中的起始地址</span></span><br><span class="line">    <span class="comment">//    = 当前文件待读取位置</span></span><br><span class="line">    <span class="comment">//      - buffer 剩余字节数</span></span><br><span class="line">    <span class="comment">//      - 刚读取的 record 头大小</span></span><br><span class="line">    <span class="comment">//      - 刚读取 record 数据部分大小</span></span><br><span class="line">    <span class="comment">// end_of_buffer_offset_ 表示 log file 待读取字节位置</span></span><br><span class="line">    <span class="comment">// buffer_ 表示是对一整个 block 数据的封装, 底层存储为 backing_store_, </span></span><br><span class="line">    <span class="comment">//    每次执行 ReadPhysicalRecord 时会移动 buffer_ 指针.</span></span><br><span class="line">    <span class="keyword">uint64_t</span> physical_record_offset =</span><br><span class="line">        end_of_buffer_offset_ - buffer_.size() - kHeaderSize - fragment.size(); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// resyncing_ 用于跳过起始地址不符合 initial_offset_ 的 record,</span></span><br><span class="line">    <span class="comment">// 如果为 true 表示目前还在定位第一个满足条件的逻辑 record 中.</span></span><br><span class="line">    <span class="comment">// 与 initial_offset_ 的比较判断在上面 ReadPhysicalRecord 中进行.</span></span><br><span class="line">    <span class="keyword">if</span> (resyncing_) &#123;</span><br><span class="line">      <span class="comment">// 只要数据没有损坏或到达文件尾, 而且返回的 record_type 只要</span></span><br><span class="line">      <span class="comment">// 不是 kBadRecord(返回该类型其中一个情况就是起始地址不满足条件)</span></span><br><span class="line">      <span class="comment">// 就说明当前 record 起始地址已经大于 initial_offset_ 了,</span></span><br><span class="line">      <span class="comment">// 但是如果当前 record 的 type 为 middle 或者 last, </span></span><br><span class="line">      <span class="comment">// 那么逻辑上这个 record 仍然与不符合 initial_offset_ 的</span></span><br><span class="line">      <span class="comment">// 类型为 first 的 record 同属一个逻辑 record, </span></span><br><span class="line">      <span class="comment">// 所以当前 record 也不是我们要的.</span></span><br><span class="line">      <span class="keyword">if</span> (record_type == kMiddleType) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (record_type == kLastType) &#123;</span><br><span class="line">        resyncing_ = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果是 full 类型的 record, 而且这个 record 起始地址</span></span><br><span class="line">        <span class="comment">// 不小于 inital_offset_(否则 ReadPhysicalRecord 返回的</span></span><br><span class="line">        <span class="comment">//     类型就是 kBadRecord 而非 full), </span></span><br><span class="line">        <span class="comment">// 满足条件了, 关掉标识.</span></span><br><span class="line">        <span class="comment">// 如果返回 kBadRecord/kEof(没什么可读了)/</span></span><br><span class="line">        <span class="comment">// 未知类型(但是起始位置满足要求), 也会关掉该标识.</span></span><br><span class="line">        resyncing_ = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意, 下面 switch 有的 case 是 return, 有的是 break.</span></span><br><span class="line">    <span class="keyword">switch</span> (record_type) &#123;</span><br><span class="line">      <span class="keyword">case</span> kFullType:</span><br><span class="line">        <span class="keyword">if</span> (in_fragmented_record) &#123;</span><br><span class="line">          <span class="comment">// 早期版本 writer 实现存在 bug. </span></span><br><span class="line">          <span class="comment">// 即如果上一个 block 末尾保存的是一个 FIRST 类型的 header, </span></span><br><span class="line">          <span class="comment">// 那么接下来 block 开头应该是一个 MIDDLE 类型的 record, </span></span><br><span class="line">          <span class="comment">// 但是早期版本写入了 FIRST 类型或者 FULL 类型的 record. </span></span><br><span class="line">          <span class="keyword">if</span> (!scratch-&gt;empty()) &#123;</span><br><span class="line">            ReportCorruption(scratch-&gt;size(), <span class="string">&quot;partial record without end(1)&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        prospective_record_offset = physical_record_offset;</span><br><span class="line">        scratch-&gt;clear();</span><br><span class="line">        <span class="comment">// 赋值构造</span></span><br><span class="line">        <span class="comment">// FULL 类型 record 不用借助 scratch 拼装了</span></span><br><span class="line">        *record = fragment; </span><br><span class="line">        last_record_offset_ = prospective_record_offset;</span><br><span class="line">        <span class="comment">// 读取到一个完整逻辑 record, 完成任务.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      <span class="comment">// 注意, 只有 first 类型的 record 起始地址满足大于 inital_offset_ 的时候</span></span><br><span class="line">      <span class="comment">// 才会返回其真实类型 first, 其它情况哪怕是 first 返回也是 kBadRecord.</span></span><br><span class="line">      <span class="keyword">case</span> kFirstType:</span><br><span class="line">        <span class="keyword">if</span> (in_fragmented_record) &#123;</span><br><span class="line">          <span class="comment">// 早期版本 writer 实现存在 bug. </span></span><br><span class="line">          <span class="comment">// 即如果上一个 block 末尾保存的是一个 FIRST 类型的 header, </span></span><br><span class="line">          <span class="comment">// 那么接下来 block 开头应该是一个 MIDDLE 类型的 record, </span></span><br><span class="line">          <span class="comment">// 但是早期版本写入了 FIRST 类型或者 FULL 类型的 record. </span></span><br><span class="line">          <span class="keyword">if</span> (!scratch-&gt;empty()) &#123;</span><br><span class="line">            ReportCorruption(scratch-&gt;size(), <span class="string">&quot;partial record without end(2)&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// FIRST 类型物理 record 起始地址也是对应逻辑 record 的起始地址</span></span><br><span class="line">        prospective_record_offset = physical_record_offset;</span><br><span class="line">        <span class="comment">// 非 FULL 类型 record 需要借助 scratch 拼装成一个完整的 record data 部分.</span></span><br><span class="line">        <span class="comment">// 注意只有 first 时采用 assign, first 后面的分片要用 append</span></span><br><span class="line">        scratch-&gt;assign(fragment.data(), fragment.size());</span><br><span class="line">        <span class="comment">// 除了 FULL 类型 record, 都说明当前读取的 record 被分片了, </span></span><br><span class="line">        <span class="comment">// 还需要后续继续读取.</span></span><br><span class="line">        in_fragmented_record = <span class="literal">true</span>; </span><br><span class="line">        <span class="comment">// 刚读了 first, 没读完, 继续.</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> kMiddleType:</span><br><span class="line">        <span class="comment">// 都存在 MIDDLE 了, 竟然还说当前 record 没分片, 报错. </span></span><br><span class="line">        <span class="keyword">if</span> (!in_fragmented_record) &#123; </span><br><span class="line">          ReportCorruption(fragment.size(),</span><br><span class="line">                           <span class="string">&quot;missing start of fragmented record(1)&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 非 FULL 类型 record 需要借助 scratch 拼装成一个</span></span><br><span class="line">          <span class="comment">// 完整的 record data 部分, </span></span><br><span class="line">          <span class="comment">// FIRST 类型已经打底了, MIDDLE 直接追加即可. </span></span><br><span class="line">          scratch-&gt;append(fragment.data(), fragment.size());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 还是 middle, 没读完, 继续.</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> kLastType:</span><br><span class="line">        <span class="comment">// 都存在 LAST 了, 竟然还说当前 record 没分片, 矛盾. </span></span><br><span class="line">        <span class="keyword">if</span> (!in_fragmented_record) &#123; </span><br><span class="line">          ReportCorruption(fragment.size(),</span><br><span class="line">                           <span class="string">&quot;missing start of fragmented record(2)&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 非 FULL 类型 record 需要借助 scratch </span></span><br><span class="line">          <span class="comment">// 拼装成一个完整的 record data 部分, </span></span><br><span class="line">          <span class="comment">// FIRST 类型已经打底了, LAST 直接追加即可. </span></span><br><span class="line">          scratch-&gt;append(fragment.data(), fragment.size());</span><br><span class="line">          *record = Slice(*scratch);</span><br><span class="line">          last_record_offset_ = prospective_record_offset;</span><br><span class="line">          <span class="comment">// 读完了, 完成任务.</span></span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> kEof:</span><br><span class="line">        <span class="comment">// 如果都读到文件尾部了, 逻辑 record 还没读全, 那就是文件损坏了. </span></span><br><span class="line">        <span class="keyword">if</span> (in_fragmented_record) &#123;</span><br><span class="line">          <span class="comment">// 可能由于 writer 写完一个物理 record 后挂掉了, </span></span><br><span class="line">          <span class="comment">// 我们不把这种情况作为数据损坏, 直接忽略整个逻辑 record.</span></span><br><span class="line">          <span class="comment">// 数据损坏, 丢掉之前可能已经解析的数据 </span></span><br><span class="line">          scratch-&gt;clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 文件尾了, 读到读不到都拜拜.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> kBadRecord:</span><br><span class="line">        <span class="comment">// 逻辑 record 有分片已经被读取过了, 但是本次读取物理 record 遇到了错误</span></span><br><span class="line">        <span class="keyword">if</span> (in_fragmented_record) &#123; </span><br><span class="line">          ReportCorruption(scratch-&gt;size(), <span class="string">&quot;error in middle of record&quot;</span>);</span><br><span class="line">          in_fragmented_record = <span class="literal">false</span>;</span><br><span class="line">          <span class="comment">// 数据损坏, 丢掉之前可能已经解析的数据</span></span><br><span class="line">          scratch-&gt;clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遇到错误也不中止, 继续读取数据进行解析直到读取完整逻辑 record 的目标达成</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">default</span>: &#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">40</span>];</span><br><span class="line">        <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">&quot;unknown record type %u&quot;</span>, record_type);</span><br><span class="line">        ReportCorruption(</span><br><span class="line">            (fragment.size() + (in_fragmented_record ? scratch-&gt;size() : <span class="number">0</span>)),</span><br><span class="line">            buf);</span><br><span class="line">        in_fragmented_record = <span class="literal">false</span>;</span><br><span class="line">        scratch-&gt;clear();</span><br><span class="line">        <span class="comment">// 遇到错误也不中止, 继续读取数据进行解析直到读取完整逻辑 record 的目标达成</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面方法中, 最重要的一个辅助函数为 <code>ReadPhysicalRecord</code>, 该方法负责从文件读取 block, 然后再从 block(block 为空但还没读取到一个完整逻辑 record, 会继续从 log 文件读取 block) 读取并解析一个物理 record 并将其 data 部分保存到 result, 同时返回该物理 record 的 type. 返回的 type 为下面几种之一:</p>
<ul>
<li>kEof, 到达文件尾</li>
<li>kBadRecord, 当前 record 损坏, 或者当前物理 record 起始地址小于用户指定的起始地址 inital_offset_(此时其实际 type 可能为 first) </li>
<li>first/middle/last/full 之一(注意, 除了 first/full, 其它类型对应物理 record 起始地址虽然不小于用户指定的 inital_offset_, 但是其所归属的逻辑 record 的起始地址可能不满足要求, 所以此时这两类物理 record 也会被 <code>Reader::ReadRecord</code> 方法跳过.)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">Reader::ReadPhysicalRecord</span><span class="params">(Slice* result)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 跳出循环需要满足下面条件之一:</span></span><br><span class="line">  <span class="comment">// - 文件损坏</span></span><br><span class="line">  <span class="comment">// - 无有效数据(非 tailer)且到达文件尾</span></span><br><span class="line">  <span class="comment">// - 读到了一个有效 block(然后解析其中的 record)</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 先确认要不要读取一个新的 blcok.</span></span><br><span class="line">    <span class="comment">// buffer_ 底层指针会向前移动, 所以其 size 是动态的. </span></span><br><span class="line">    <span class="comment">// 如果 buffer 剩余内容字节数小于 kHeaderSize 且不为空, </span></span><br><span class="line">    <span class="comment">// 表示 buffer 里面剩余字节是个 trailer, 可以跳过它去读取解析下个 block 了;</span></span><br><span class="line">    <span class="comment">// 否则, 跳过 if 继续从该 block 解析 record.</span></span><br><span class="line">    <span class="keyword">if</span> (buffer_.size() &lt; kHeaderSize) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!eof_) &#123; <span class="comment">// 如果未到文件尾</span></span><br><span class="line">        <span class="comment">// Last read was a full read, so this is a trailer to skip</span></span><br><span class="line">        buffer_.clear();</span><br><span class="line">        <span class="comment">// 从 log file 读取一整个 block 放到 backing_store_, </span></span><br><span class="line">        <span class="comment">// 然后将 backing_store_ 封装到 buffer_ 中. </span></span><br><span class="line">        Status status = file_-&gt;Read(kBlockSize, &amp;buffer_, backing_store_);</span><br><span class="line">        <span class="comment">// 更新 end_of_buffer_offset_ 至迄今从 log 读取最大位置下一个字节</span></span><br><span class="line">        end_of_buffer_offset_ += buffer_.size(); </span><br><span class="line">        <span class="comment">// 如果 log 文件损坏</span></span><br><span class="line">        <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">          buffer_.clear();</span><br><span class="line">          <span class="comment">// 一个 block 被丢掉</span></span><br><span class="line">          ReportDrop(kBlockSize, status);</span><br><span class="line">          <span class="comment">// 读文件失败我们认为到达文件尾; </span></span><br><span class="line">          <span class="comment">// 注意, file_-&gt;Read 读到文件尾不会报错因为这是正常情况.</span></span><br><span class="line">          <span class="comment">// 只有遇到错误才会报错. </span></span><br><span class="line">          eof_ = <span class="literal">true</span>; </span><br><span class="line">          <span class="keyword">return</span> kEof;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (buffer_.size() &lt; kBlockSize) &#123;</span><br><span class="line">          <span class="comment">// 如果读取的 block 数据小于 block 容量, </span></span><br><span class="line">          <span class="comment">// 则肯定到达 log 文件尾部了, 处理其中的 records.</span></span><br><span class="line">          eof_ = <span class="literal">true</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 注意, 如果 buffer_ 非空, 则其内容为一个</span></span><br><span class="line">        <span class="comment">// 位于文件尾的截断的 record header. </span></span><br><span class="line">        <span class="comment">// 这可能是因为 writer 写 header 时崩溃导致的. </span></span><br><span class="line">        <span class="comment">// 我们不会把这种情况当做错误, 而是当做读作文件尾来处理. </span></span><br><span class="line">        buffer_.clear();</span><br><span class="line">        <span class="keyword">return</span> kEof;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注意, 一个 block 可以包含多个 records, </span></span><br><span class="line"><span class="comment">     * 但是 block 最后一个 record 可能只包含 </span></span><br><span class="line"><span class="comment">     * header(这是由于 block 最后只剩下 7 个字节)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 解析 record 的 header.</span></span><br><span class="line">    <span class="comment">// record header, 由 checksum (4 bytes), </span></span><br><span class="line">    <span class="comment">// length (2 bytes), type (1 byte) 构成. </span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* header = buffer_.data(); </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下面两步骤是解析 length 的两个字节, 小端字节序, 所以需要拼, </span></span><br><span class="line"><span class="comment">     * 具体见 Writer::EmitPhysicalRecord</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// xxxx|(xx|x|x)xxxxx 将左边括号内容转换为无符号 32 位数,</span></span><br><span class="line">    <span class="comment">// 并取出最后 8 位即括号左起第一个 x</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> a = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(header[<span class="number">4</span>]) &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="comment">// xxxx|x(x|x|xx)xxxx 将左边括号内容转换为无符号 32 位数,</span></span><br><span class="line">    <span class="comment">// 并取出最后 8 位即括号左起第一个 x</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> b = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(header[<span class="number">5</span>]) &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="comment">// xxxx|xx|(x)|xxxxxx 读取左边括号内容即 record type</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> type = header[<span class="number">6</span>]; </span><br><span class="line">    <span class="comment">// b 和 a 拼接构成了 length</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> length = a | (b &lt;&lt; <span class="number">8</span>); </span><br><span class="line">    <span class="comment">// 如果解析出的 length 加上 header 长度大于 buffer_ 剩余数据长度, </span></span><br><span class="line">    <span class="comment">// 则说明数据损坏了, 比如 length 被篡改了. </span></span><br><span class="line">    <span class="keyword">if</span> (kHeaderSize + length &gt; buffer_.size()) &#123;</span><br><span class="line">      <span class="keyword">size_t</span> drop_size = buffer_.size();</span><br><span class="line">      buffer_.clear();</span><br><span class="line">      <span class="comment">// 如果未到文件尾, 报告 length 损坏. </span></span><br><span class="line">      <span class="keyword">if</span> (!eof_) &#123; </span><br><span class="line">        ReportCorruption(drop_size, <span class="string">&quot;bad record length&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> kBadRecord;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果已经到了文件尾, 即当前读取 block 为 log file 最后一个 block.</span></span><br><span class="line">      <span class="comment">// 由于 length  有问题我们也没必要也没办法读取 data 部分, </span></span><br><span class="line">      <span class="comment">// 我们假设这种情况原因是 writer 写数据时崩溃了. </span></span><br><span class="line">      <span class="comment">// 这种情况我们不作为错误去报告, 而是当做到达文件尾了. </span></span><br><span class="line">      <span class="keyword">return</span> kEof;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type == kZeroType &amp;&amp; length == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 跳过 0 长度的 record, 而且不会报告数据丢弃. </span></span><br><span class="line">      <span class="comment">// 因为这些 records 产生的原因是 env_posix.cc </span></span><br><span class="line">      <span class="comment">// 中基于 mmap 的写入代码在执行时会预分配文件区域. </span></span><br><span class="line">      buffer_.clear();</span><br><span class="line">      <span class="keyword">return</span> kBadRecord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check crc</span></span><br><span class="line">    <span class="keyword">if</span> (checksum_) &#123;</span><br><span class="line">      <span class="comment">// 读取 crc</span></span><br><span class="line">      <span class="keyword">uint32_t</span> expected_crc = crc32c::Unmask(DecodeFixed32(header)); </span><br><span class="line">      <span class="comment">// crc 是基于 type 和 data 来计算的</span></span><br><span class="line">      <span class="keyword">uint32_t</span> actual_crc = crc32c::Value(header + <span class="number">6</span>, <span class="number">1</span> + length); </span><br><span class="line">      <span class="keyword">if</span> (actual_crc != expected_crc) &#123;</span><br><span class="line">        <span class="comment">// crc 校验失败, 可能是 length 字段出错, 数据损坏,</span></span><br><span class="line">        <span class="comment">// 丢弃这个 block 的剩余部分</span></span><br><span class="line">        <span class="keyword">size_t</span> drop_size = buffer_.size();</span><br><span class="line">        buffer_.clear();</span><br><span class="line">        ReportCorruption(drop_size, <span class="string">&quot;checksum mismatch&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> kBadRecord;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// header 解析完毕, 将当前 record 从 buffer_ 中</span></span><br><span class="line">    <span class="comment">// 移除(通过向前移动 buffer_ 底层存储指针实现)</span></span><br><span class="line">    buffer_.remove_prefix(kHeaderSize + length); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前解析出的 record 起始地址小于用户指定的起始地址, </span></span><br><span class="line">    <span class="comment">// 则跳过这个 record(返回 kBadRecord 类型). </span></span><br><span class="line">    <span class="comment">// 注意, 此时真正的 record type 可能为 first 类型.</span></span><br><span class="line">    <span class="keyword">if</span> (end_of_buffer_offset_ - buffer_.size() - kHeaderSize - length</span><br><span class="line">        &lt; initial_offset_) &#123;</span><br><span class="line">      result-&gt;clear();</span><br><span class="line">      <span class="keyword">return</span> kBadRecord;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将该 record 的 data 部分返回</span></span><br><span class="line">    *result = Slice(header + kHeaderSize, length); </span><br><span class="line">    <span class="keyword">return</span> type;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1><span id="写-log">写 log</span></h1><p>下面分析写 log 相关的类和方法.</p>
<h2><span id="核心文件与核心类">核心文件与核心类</span></h2><p>与写 log 相关的代码定义在下面两个文件中:</p>
<pre><code>db/log_writer.h
db/log_writer.cc</code></pre>
<p>核心类为 <code>class leveldb::log::Writer</code>. 下面针对这个类核心方法进行分析.    </p>
<h2><span id="writer-构造方法">Writer 构造方法</span></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 writer 用于追加数据到 dest 指向的文件.</span></span><br><span class="line"><span class="comment">// dest 指向的文件初始必须为空文件; dest 生命期不能短于 writer.</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Writer</span><span class="params">(WritableFile *dest)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 writer 用于追加数据到 dest 指向的文件.</span></span><br><span class="line"><span class="comment">// dest 指向文件初始长度必须为 dest_length; dest 生命期不能短于 writer.</span></span><br><span class="line">Writer(WritableFile *dest, <span class="keyword">uint64_t</span> dest_length);</span><br></pre></td></tr></table></figure>

<h2><span id="writer-写方法">Writer 写方法</span></h2><p>如果用户想把数据写入 log, 则需要将这些数据封装为 <code>Slice</code>, 然后调用 <code>Writer::AddRecord</code> 将其写入 log 文件. </p>
<p>写入时, 这个 <code>Slice</code> 内容即为 record 的 data 部分, 如果数据量太大导致一个 block(默认 32KB) 装不下, 则这些数据会被分片写入. 也就是说, 这些数据属于一个逻辑 record, 但是因为太大, 被分为若干物理 record 写入到 log 文件.</p>
<p>具体写入流程见源码注释:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Writer::AddRecord</span><span class="params">(<span class="keyword">const</span> Slice&amp; slice)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* ptr = slice.data();</span><br><span class="line">  <span class="comment">// data 剩余部分长度, 初始值为其原始长度</span></span><br><span class="line">  <span class="keyword">size_t</span> left = slice.size(); </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如有必要则将 record 分片后写入文件. </span></span><br><span class="line">  <span class="comment">// 如果 slice 内容为空, 则我们仍将会写入一个长度为 0 的 record 到文件中. </span></span><br><span class="line">  Status s;</span><br><span class="line">  <span class="keyword">bool</span> begin = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 当前 block 剩余空间大小</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> leftover = kBlockSize - block_offset_; </span><br><span class="line">    assert(leftover &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 如果当前 block 剩余空间不足容纳 record 的 header(7 字节) </span></span><br><span class="line">    <span class="comment">// 则剩余空间作为 trailer 填充 0, 然后切换到新的 block.</span></span><br><span class="line">    <span class="keyword">if</span> (leftover &lt; kHeaderSize) &#123; </span><br><span class="line">      <span class="keyword">if</span> (leftover &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        assert(kHeaderSize == <span class="number">7</span>);</span><br><span class="line">        <span class="comment">// 最终填充多少 0 由 leftover 决定, 最大 6 字节</span></span><br><span class="line">        dest_-&gt;Append(Slice(<span class="string">&quot;\x00\x00\x00\x00\x00\x00&quot;</span>, leftover)); </span><br><span class="line">      &#125;</span><br><span class="line">      block_offset_ = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这一步, block (可能因为不足 kHeaderSize 在上面已经切换到了下个 block)</span></span><br><span class="line">    <span class="comment">// 最终剩余字节必定大约等于 kHeaderSize</span></span><br><span class="line">    assert(kBlockSize - block_offset_ - kHeaderSize &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// block 当前剩余空闲字节数.</span></span><br><span class="line">    <span class="comment">// 除了待写入 header, 当前 block 还剩多大空间, 可能为 0; </span></span><br><span class="line">    <span class="comment">// block 最后剩下空间可能只够写入一个新 record 的 header 了</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> avail = kBlockSize - block_offset_ - kHeaderSize;</span><br><span class="line">    <span class="comment">// 可以写入当前 block 的 record data 剩余内容的长度, 可能为 0</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> fragment_length = (left &lt; avail) ? left : avail;</span><br><span class="line"></span><br><span class="line">    RecordType type; </span><br><span class="line">    <span class="comment">// 判断是否将 record 剩余内容分片</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> end = (left == fragment_length);</span><br><span class="line">    <span class="keyword">if</span> (begin &amp;&amp; end) &#123;</span><br><span class="line">      <span class="comment">// 如果该 record 内容第一次写入文件, 而且, </span></span><br><span class="line">      <span class="comment">// 如果 block 剩余空间可以容纳 record data 全部内容, </span></span><br><span class="line">      <span class="comment">// 则写入一个 full 类型 record</span></span><br><span class="line">      type = kFullType;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (begin) &#123;</span><br><span class="line">      <span class="comment">// 如果该 record 内容第一写入文件, 而且, </span></span><br><span class="line">      <span class="comment">// 如果 block 剩余空间无法容纳 record data 全部内容, </span></span><br><span class="line">      <span class="comment">// 则写入一个 first 类型 record. </span></span><br><span class="line">      <span class="comment">// 注意, 此时是 record 第一次写入即它是一个新 record, </span></span><br><span class="line">      <span class="comment">//    该 block 剩余空间可能只够容纳 header 了, </span></span><br><span class="line">      <span class="comment">//    则在 block 尾部写入一个 FIRST 类型 header, record data 不写入, </span></span><br><span class="line">      <span class="comment">//    等下次循环会切换到下个 block, 然后又会重新写入一个</span></span><br><span class="line">      <span class="comment">//    非 FIRST 类型的 header (注意下面会将 begin 置为 false)</span></span><br><span class="line">      <span class="comment">//    而不是紧接着在新 block 只写入 data 部分. </span></span><br><span class="line">      type = kFirstType;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end) &#123;</span><br><span class="line">      <span class="comment">// 如果这不是该 record 内容第一写入文件, 而且, </span></span><br><span class="line">      <span class="comment">// 如果 block 剩余空间可以容纳 record data 剩余内容, </span></span><br><span class="line">      <span class="comment">// 则写入一个 last 类型 record</span></span><br><span class="line">      type = kLastType;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果这不是该 record 内容第一写入文件, 而且, </span></span><br><span class="line">      <span class="comment">// 如果 block 剩余空间无法容纳 record data 剩余内容, </span></span><br><span class="line">      <span class="comment">// 则写入一个 middle 类型 record</span></span><br><span class="line">      type = kMiddleType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将类型为 type, data 长度为 fragment_length 的 record 写入 log 文件.</span></span><br><span class="line">    s = EmitPhysicalRecord(type, ptr, fragment_length);</span><br><span class="line">    ptr += fragment_length;</span><br><span class="line">    left -= fragment_length;</span><br><span class="line">    <span class="comment">// 即使当前 block 剩余空间只够写入一个新 record 的 FIRST 类型 header, </span></span><br><span class="line">    <span class="comment">// record 也算写入过了</span></span><br><span class="line">    begin = <span class="literal">false</span>; </span><br><span class="line">    <span class="comment">// 写入不出错且 record 再无剩余内容则写入完毕</span></span><br><span class="line">  &#125; <span class="keyword">while</span> (s.ok() &amp;&amp; left &gt; <span class="number">0</span>); </span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>‘AddRecord<code>写入 record 时依赖的辅助方法</code>EmitPhysicalRecord`. 该方法负责组装 record header, 然后连同 payload 写入文件.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Writer::EmitPhysicalRecord</span><span class="params">(RecordType t, <span class="keyword">const</span> <span class="keyword">char</span>* ptr, <span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// data 大小必须能够被 16 位无符号整数表示, 因为 record 的 length 字段只有两字节</span></span><br><span class="line">  assert(n &lt;= <span class="number">0xffff</span>);</span><br><span class="line">  <span class="comment">// 要写入的内容不能超过当前 block 剩余空间大小</span></span><br><span class="line">  assert(block_offset_ + kHeaderSize + n &lt;= kBlockSize); </span><br><span class="line"></span><br><span class="line">  <span class="comment">// buf 用于组装 record header</span></span><br><span class="line">  <span class="keyword">char</span> buf[kHeaderSize];</span><br><span class="line">  <span class="comment">// 将数据长度编码到 length 字段, 小端字节序</span></span><br><span class="line">  <span class="comment">// length 低 8 位安排在低地址位置</span></span><br><span class="line">  buf[<span class="number">4</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(n &amp; <span class="number">0xff</span>); </span><br><span class="line">  <span class="comment">// 然后写入 length 高 8 位安排在高地址位置</span></span><br><span class="line">  buf[<span class="number">5</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(n &gt;&gt; <span class="number">8</span>); </span><br><span class="line">  <span class="comment">// 将 type 编码到 type 字段, type 紧随 length 之后 1 字节</span></span><br><span class="line">  buf[<span class="number">6</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(t); </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算 type 和 data 的 crc 并编码安排在最前面 4 个字节</span></span><br><span class="line">  <span class="keyword">uint32_t</span> crc = crc32c::Extend(type_crc_[t], ptr, n);</span><br><span class="line">  crc = crc32c::Mask(crc);</span><br><span class="line">  <span class="comment">// 将 crc 写入到 header 前四个字节</span></span><br><span class="line">  EncodeFixed32(buf, crc);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 写入 header</span></span><br><span class="line">  Status s = dest_-&gt;Append(Slice(buf, kHeaderSize)); </span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    <span class="comment">// 写入 payload</span></span><br><span class="line">    s = dest_-&gt;Append(Slice(ptr, n));</span><br><span class="line">    <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">      <span class="comment">// 刷入文件</span></span><br><span class="line">      s = dest_-&gt;Flush();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当前 block 剩余空间起始偏移量. </span></span><br><span class="line">  <span class="comment">// 注意, 这里不管 header 和 data 是否写成功. </span></span><br><span class="line">  block_offset_ += kHeaderSize + n; </span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>–End–</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://chielungcheung.github.io/2020/09/21/%E4%BD%BF%E7%94%A8-eBPF-%E8%B0%83%E8%AF%95%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E7%9A%84-Go-%E7%A8%8B%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chienlung Cheung">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="programatrix">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/21/%E4%BD%BF%E7%94%A8-eBPF-%E8%B0%83%E8%AF%95%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E7%9A%84-Go-%E7%A8%8B%E5%BA%8F/" class="post-title-link" itemprop="url">使用 eBPF 调试生产环境的 Go 程序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-21 22:43:27" itemprop="dateCreated datePublished" datetime="2020-09-21T22:43:27+00:00">2020-09-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-25 06:37:30" itemprop="dateModified" datetime="2020-09-25T06:37:30+00:00">2020-09-25</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2020/09/21/%E4%BD%BF%E7%94%A8-eBPF-%E8%B0%83%E8%AF%95%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E7%9A%84-Go-%E7%A8%8B%E5%BA%8F/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/09/21/使用-eBPF-调试生产环境的-Go-程序/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!-- toc -->

<ul>
<li><a href="#%E4%BB%8B%E7%BB%8D">介绍</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF-ebpf">什么是 eBPF</a></li>
<li><a href="#uprobes">Uprobes</a></li>
<li><a href="#%E6%9E%84%E5%BB%BA%E8%BF%BD%E8%B8%AA%E7%A8%8B%E5%BA%8F">构建追踪程序</a></li>
<li><a href="#%E7%95%AA%E5%A4%96">番外</a><ul>
<li><a href="#%E5%AE%89%E8%A3%85-bcc">安装 BCC</a></li>
<li><a href="#too-many-arguments-%E7%BC%96%E8%AF%91%E9%94%99%E8%AF%AF">too many arguments 编译错误</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<p>最新的 Go Weekly 推送了<a target="_blank" rel="noopener" href="https://blog.pixielabs.ai/blog/ebpf-function-tracing/post/">这篇文章</a>, eBPF 作为新时代的剖析工具正在如火如荼发展, 读完感觉用来入门很好, 就根据自己理解编译了这篇文章. 做实验过程遇到一些问题, 在最后加了一个番外章节可参考.</p>
<p>下面正式开始.</p>
<p>不用重新编译/部署线上程序而是借助 eBPF 即可实现对程序进行调试, 接下来我们会用一个系列文章介绍我们是怎么做的, 这是开篇. 本篇描述了如何使用 <a target="_blank" rel="noopener" href="https://github.com/iovisor/gobpf">gobpf</a> 和 uprobe 来构建一个跟踪 Go 程序函数入口参数变化的应用. 这里介绍的技术可以扩展到其它编译型语言, 如 C++, Rust 等等. 本系列文章后续将会讨论如何使用 eBPF 来跟踪 HTTP/gRPC 数据和 SSL 等等.</p>
<h1><span id="介绍">介绍</span></h1><p>当调试程序时, 我们一般对捕获程序的运行时状态非常感兴趣. 因为这可以让我们检查程序在干什么, 并能让我们确定 bug 出现在程序的哪一块. 观察运行时状态的一个简单方式是使用调试器. 比如针对 Go 程序, 我们可以使用 Delve 和 gdb.</p>
<p>Delve 和 gdb 在开发环境中做调试表现没得说, 但是我们一般不会在线上使用此类工具. 它们的长处同时也是它们的短处, 因为调试器会导致线上程序中断, 甚至如果在调试过程中不小心改错某个变量的值而导致线上程序出现异常.</p>
<p>为了让线上调试过程的侵入和影响更小, 我们将会探索使用增强版的 BPF(<a target="_blank" rel="noopener" href="https://ebpf.io/">eBPF</a>, Linux 4.x+ 内核可用)和更高级的 Go 库 <a target="_blank" rel="noopener" href="https://github.com/iovisor/gobpf">gobpf</a> 来达成目标.</p>
<h1><span id="什么是-ebpf">什么是 eBPF</span></h1><p>扩展型 BPF(eBPF) 是一项在 Linux 4.x+ 内核可用的技术. 你可以把它看作一个轻量级的沙箱 VM, 它运行在 Linux 内核中并且提供了针对内核内存的可信访问.</p>
<p>就像下面要说的, eBPF 允许内核运行 BPF 字节码. 虽然可用的前端(这里指的是编译器前端)语言多样, 但通常都是 C 语言的真子集. 通常 C 代码先通过 Clang 被编译为 BPF 字节码, 然后字节被验证以确保可以安全执行. 这些严格的验证保证了机器码不会有意或无意地危及 Linux 内核, 同时也确保了 BPF 探针在每次被触发时将会执行有限数目的指令. 这些保证确保了 eBPF 可以被用于性能敏感的应用中, 比如包过滤, 网络监控等等.</p>
<p>从功能上说, eBPF 允许你针对某些事件(如定时器事件, 网络事件或是函数调用事件)运行受限的 C 代码. 当因为一个函数调用事件被触发时, 我们把这些 eBPF 代码叫做探针. 这些探针既可以针对内核函数调用事件被触发(这时叫 kprobe, k 即 kernelspace), 也可以针对用户空间的函数调用事件被触发(这时叫 uprobe, u 即 userspace). 本篇文章讲解如何通过 uprobe 实现函数参数的动态追踪.</p>
<h1><span id="uprobes">Uprobes</span></h1><p>Uprobes 允许我们通过插入一个 debug trap 指令(在 x86 上就是 <code>int3</code>)触发一个软中断从而实现对运行在用户空间的程序进行拦截. 这也是调试器的工作原理. uprobe 运行过程本质上与其它 BPF 程序一样, 可以总结为下面图示:<br><img src="http://www.brendangregg.com/eBPF/linux_ebpf_internals.png" alt="BPF for tracing(from Brendan Gregg)"></p>
<center style="font-size:14px;color:#C0C0C0;text-decoration:underline">用于跟踪的 BPF(来自 Brendan Gregg)</center> 

<p>编译和验证过的 BPF 程序作为 uprobe 的一部分被执行, 同时执行结果写入到一个 buffer 中.</p>
<p>下面让我们研究下 uprobes 如何起作用的. 为了演示部署 uprobes 并捕获函数参数, 我们会用到<a target="_blank" rel="noopener" href="https://github.com/pixie-labs/pixie/blob/main/demos/simple-gotracing/app.go">这个</a>简单的 demo 应用. 该 demo 相关部分下面介绍.</p>
<p><code>main()</code> 方法是一个简单的 HTTP server, 它暴露了一个监听 <em>/e</em> 端点的 <em>GET</em> 接口, 该接口通过迭代逼近计算自然常数 <code>e</code>(也叫欧拉数). <code>computeE</code> 方法有一个参数 <em>iters</em>, 它指定了逼近时的迭代次数. 迭代次数越多, 结果越精确, 当然耗费 CPU 也越多. 迭代逼近算法不是我们本次关注重点, 感兴趣的可以自己研究下. 我们仅对追踪调用 <code>computeE</code> 方法时的参数感兴趣.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">computeE</span><span class="params">(iterations <span class="keyword">int64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">  res := <span class="number">2.0</span></span><br><span class="line">  fact := <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i := <span class="keyword">int64</span>(<span class="number">2</span>); i &lt; iterations; i++ &#123;</span><br><span class="line">    fact *= <span class="keyword">float64</span>(i)</span><br><span class="line">    res += <span class="number">1</span> / fact</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  http.HandleFunc(<span class="string">&quot;/e&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ... 省略代码用于从 get 请求中解析 iters 参数, 若为空则使用默认值</span></span><br><span class="line">    w.Write([]<span class="keyword">byte</span>(fmt.Sprintf(<span class="string">&quot;e = %0.4f\n&quot;</span>, computeE(iters))))</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 启动 server...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了进行后面的实验以及为最后采用 gdb 验证修改生效, 我们采用如下指令编译该代码:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go build  -gcflags <span class="string">&quot;-N -l&quot;</span> app.go</span><br></pre></td></tr></table></figure>

<p>为了理解 uprobe 如何工作的, 我们看看可执行文件中要追踪的符号. 既然 uprobes 通过插入一个 debug trap 指令到可执行文件来实现, 我们先要确定要追踪的函数地址是什么. Go 程序在 Linux 上的二进制采用 ELF 格式存储 debug 信息, 该信息甚至在优化过的二进制中也是存在的, 除非 debug 数据被裁剪掉了. 我们可以使用命令 <code>objdump</code> 来检查二进制文件中的符号:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行下面命令之前需要你先将上面 go 程序编译为名为 app 的二进制文件.</span></span><br><span class="line"><span class="comment"># objdump --syms 可以从可执行程序中导出全部符号, 然后通过 grep 查找 computeE.</span></span><br><span class="line"><span class="comment"># 具体输出可能与你机器上不同, 这没什么问题.</span></span><br><span class="line">$ objdump --syms app | grep computeE</span><br><span class="line">00000000000x6600e0 g     F .text  000000000000004b             main.computeE</span><br></pre></td></tr></table></figure>

<p>从上述输出可以看到, <code>computeE</code> 方法的入口地址为 <code>0x0x6600e0</code>. 为了看一下这个地址附近的指令, 我们可以通过 <code>objdump</code> 来反汇编该二进制文件(通过命令行选项 <code>-d</code>). 反汇编代码如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ objdump -d app | grep -A 1 0x6600e0</span><br><span class="line">00000000000x6600e0 &lt;main.computeE&gt;:</span><br><span class="line">  0x6600e0:       48 8b 44 24 08          mov    0x8(%rsp),%rax</span><br></pre></td></tr></table></figure>

<p>从上面汇编代码可以看到当 <code>computeE</code> 方法被调用时会执行哪些指令. 第一条指令是 <code>mov 0x8(%rsp),%rax</code>, 该指令将距寄存器 <code>rsp</code> 保存的地址(栈指针寄存器保存的是 <code>computeE</code> 方法的入口地址)相对偏移量为 <code>0x8</code> 处的内容移动到寄存器 <code>rax</code> 中. 这个被移动的值即为 <code>computeE</code> 方法的入参 <code>iterations</code> 的值. Go 程序的参数通过栈来传递.</p>
<p>好了, 记住上面提到的信息, 我们来看看如何实现针对 <code>computeE</code> 方法的参数追踪.</p>
<h1><span id="构建追踪程序">构建追踪程序</span></h1><p>我们给这个追踪程序起个名叫 Tracer. 为了捕获前面提到的事件, 我们需要注册一个 uprobe 函数, 并且还得有个用户态函数负责去读 uprobe 的输出, 具体如下图所示:</p>
<p><img src="https://blog.pixielabs.ai/static/9f8b26f88f9b132440ef1b9d48b5a341/app-tracer.svg" alt="High-level overview showing the Tracer binary listening to perf events generated from the App"></p>
<p>我们编写一个叫做 <code>tracer</code> 的应用, 由它负责注册 BPF 代码, 同时读取这些 BPF 代码的输出. 如上图所示, uprobe 将会简单地输出到一个 <code>perf-buffer</code> 中, 该结构体是用于 perf 事件的 linux 内核数据结构. </p>
<p>万事俱备, 我们来看看当我们增加一个 uprobe 时会发生哪些事情. 下面的图显示了 Linux 内核如何使用一个 uprobe 来修改一个已有的二进制程序. 前文提到的软中断 <code>int3</code> 作为第一条指令被插入到 <code>main.computeE</code> 方法中. 这条指令将会在执行时触发一个软中断, 从而允许 Linux 内核来执行 BPF 代码. 然后我们把 <code>computeE</code> 每次被调用时的参数输出到 perf-buffer 中, 这些值会被我们编写的 <code>tracer</code> 应用异步地读取.</p>
<p><img src="https://blog.pixielabs.ai/static/87301c7282e8f8270fee2afb9fe85c81/app-trace.svg" alt="Details of how a debug trap instruction is used call a BPF program"></p>
<p>就我们这个需求来说, 相应的 BPF 代码很简单, C 代码如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;uapi/linux/ptrace.h&gt;</span></span></span><br><span class="line">BPF_PERF_OUTPUT(trace);</span><br><span class="line"><span class="comment">// 该函数将会被注册, 以便每次 main.computeE 被调用时该函数也会被调用</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">computeECalled</span><span class="params">(struct pt_regs *ctx)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// main.computeE 的入参保存在了 ax 寄存器里.</span></span><br><span class="line">  <span class="keyword">long</span> val = ctx-&gt;ax;</span><br><span class="line">  trace.perf_submit(ctx, &amp;val, <span class="keyword">sizeof</span>(val));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们注册上面代码以便 <code>main.computeE</code> 方法被调用它们也会被执行. 这些代码被执行时, 我们仅仅读取函数参数然后写到 perf-buffer 中. 实现这个功能需要很多样板代码, 为了方便示意这里都省掉了, 完整的例子见<a target="_blank" rel="noopener" href="https://github.com/pixie-labs/pixie/blob/main/demos/simple-gotracing/trace_example/trace.go">这里</a>.</p>
<p>好了, 我们现在有个针对 <code>main.computeE</code> 的功能齐全的端到端参数追踪器了! 执行结果见下面动图:<br><img src="https://blog.pixielabs.ai/static/4de8713a5b05e1f9132350f333572174/e2e-demo.gif" alt="End-to-End demo"></p>
<p>上述动图执行步骤如下:</p>
<ul>
<li>1 在 localhost:9090 启动待追踪程序 <code>./app</code>, 此时我们可以用 curl 访问该应用了, 具体命令为 <code>curl http://localhost:9090/e?iters=10</code></li>
<li>2 启动 trace 应用, 注意指定参数 <code>sudo ./trace --binary ../app/app</code>, 参数是第一步中待追踪程序对应的二进制文件的路径.</li>
<li>3 不停的执行 curl 命令, 使其 iters 参数取值不同, 则会看到 trace 应用输出你指定的 iters 值.</li>
</ul>
<p>还有个有意思的事情, 我们真的可以通过 GDB 看到针对二进制文件的修改. 下面我们 dump 出 <code>0x0x6600e0</code> 处的指令, 在我们运行 <code>trace</code> 之前是这样的:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ gdb ./app</span><br><span class="line">(gdb) display /4i 0x6600e0</span><br><span class="line">1: x/4i 0x6600e0</span><br><span class="line">   0x6600e0 &lt;main.computeE&gt;:    sub    <span class="variable">$0x20</span>,%rsp</span><br><span class="line">   0x6600e4 &lt;main.computeE+4&gt;:  mov    %rbp,0x18(%rsp)</span><br><span class="line">   0x6600e9 &lt;main.computeE+9&gt;:  lea    0x18(%rsp),%rbp</span><br><span class="line">   0x6600ee &lt;main.computeE+14&gt;: xorps  %xmm0,%xmm0</span><br></pre></td></tr></table></figure>

<p>在我们运行 <code>trace</code> 之后, 再次查看:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ gdb ./app</span><br><span class="line">(gdb) display /4i 0x65fecf</span><br><span class="line">2: x/4i 0x6600e0</span><br><span class="line">   0x6600e0 &lt;main.computeE&gt;:    int3   </span><br><span class="line">   0x6600e1 &lt;main.computeE+1&gt;:  sub    <span class="variable">$0x20</span>,%esp</span><br><span class="line">   0x6600e4 &lt;main.computeE+4&gt;:  mov    %rbp,0x18(%rsp)</span><br><span class="line">   0x6600e9 &lt;main.computeE+9&gt;:  lea    0x18(%rsp),%rbp</span><br></pre></td></tr></table></figure>

<p>看到了吗? <code>0x6600e0</code> 插入了 <code>int3</code> 指令.</p>
<h1><span id="番外">番外</span></h1><p>下面说一下实验过程遇到的问题以及解决办法.</p>
<h2><span id="安装-bcc">安装 BCC</span></h2><p>编译前文提到的 <code>trace</code> 应用之前需要安装 bcc. 以 Ubuntu 16.04 为例(其它系统请参考<a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc/blob/master/INSTALL.md">这里</a>):</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 4052245BD4284CDD</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb https://repo.iovisor.org/apt/<span class="subst">$(lsb_release -cs)</span> <span class="subst">$(lsb_release -cs)</span> main&quot;</span> | sudo tee /etc/apt/sources.list.d/iovisor.list</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install bcc-tools libbcc-examples linux-headers-$(uname -r)</span><br></pre></td></tr></table></figure>

<p>如果安装速度慢, 而且你设置了 http_proxy/https_proxy, 请编辑 <code>/etc/sudoers</code> 新增一行 <code>Defaults env_keep = &quot;http_proxy https_proxy&quot;</code>, 这样速度至少会有百倍提升.</p>
<h2><span id="too-many-arguments-编译错误">too many arguments 编译错误</span></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># github.com/iovisor/gobpf/bcc</span><br><span class="line">../../../../<span class="keyword">go</span>/pkg/mod/github.com/iovisor/gobpf@v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200614202714</span>-e6b321d32103/bcc/module.<span class="keyword">go</span>:<span class="number">98</span>:<span class="number">40</span>: too many arguments in call to _Cfunc_bpf_module_create_c_from_string</span><br><span class="line">        have (*_Ctype_char, number, **_Ctype_char, _Ctype_int, _Ctype__Bool, <span class="literal">nil</span>)</span><br><span class="line">        want (*_Ctype_char, _Ctype_uint, **_Ctype_char, _Ctype_int, _Ctype__Bool)</span><br><span class="line">../../../../<span class="keyword">go</span>/pkg/mod/github.com/iovisor/gobpf@v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200614202714</span>-e6b321d32103/bcc/module.<span class="keyword">go</span>:<span class="number">230</span>:<span class="number">28</span>: too many arguments in call to _C2func_bcc_func_load</span><br><span class="line">        have (unsafe.Pointer, _Ctype_int, *_Ctype_char, *_Ctype_struct_bpf_insn, _Ctype_int, *_Ctype_char, _Ctype_uint, _Ctype_int, *_Ctype_char, _Ctype_uint, <span class="literal">nil</span>)</span><br><span class="line">        want (unsafe.Pointer, _Ctype_int, *_Ctype_char, *_Ctype_struct_bpf_insn, _Ctype_int, *_Ctype_char, _Ctype_uint, _Ctype_int, *_Ctype_char, _Ctype_uint)</span><br></pre></td></tr></table></figure>

<p>原因为<a target="_blank" rel="noopener" href="https://github.com/iovisor/gobpf/commit/3ecafd366e4b239946d03c17f5a4beb5aef4935e#diff-f11d8f44bec322f0ba3a2ee148c82966">这一行</a>增加的特性 <em>Update bcc_func_load to libbcc 0.11 with hardware offload support</em>, 以及<a target="_blank" rel="noopener" href="https://github.com/iovisor/gobpf/commit/cda73bdde3bf14fc898d07b8936073e1aa197708">这一行</a>增加的特性 <em>bcc: update bpf_module_create_c_from_string for bcc 0.11.0 (fixes #202)</em>. </p>
<p>我没有深究具体是什么导致的(初步怀疑是系统版本), 如果你急着看结果, 可以根据上面报错地址知道到 <code>module.go</code> 文件, 把涉及的两个函数的最后一个 <code>nil</code> 参数去掉就可以顺利编译了.</p>
<p>–End–</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://chielungcheung.github.io/2020/09/11/leveldb-annotations-1-interfaces-and-files/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chienlung Cheung">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="programatrix">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/11/leveldb-annotations-1-interfaces-and-files/" class="post-title-link" itemprop="url">Leveldb 原理详解系列之一: 接口与文件</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-11 23:13:08" itemprop="dateCreated datePublished" datetime="2020-09-11T23:13:08+00:00">2020-09-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-25 06:37:30" itemprop="dateModified" datetime="2020-09-25T06:37:30+00:00">2020-09-25</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2020/09/11/leveldb-annotations-1-interfaces-and-files/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/09/11/leveldb-annotations-1-interfaces-and-files/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!-- toc -->

<ul>
<li><a href="#%E4%BB%8E%E5%93%AA%E9%87%8C%E7%9D%80%E6%89%8B%E5%88%86%E6%9E%90-leveldb-%E5%AE%9E%E7%8E%B0">从哪里着手分析 leveldb 实现</a></li>
<li><a href="#leveldb-%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%A5%E5%8F%A3">leveldb 常用的接口</a><ul>
<li><a href="#open">Open</a></li>
<li><a href="#put">Put</a></li>
<li><a href="#delete">Delete</a></li>
<li><a href="#write">Write</a></li>
<li><a href="#get">Get</a></li>
<li><a href="#newiterator">NewIterator</a></li>
<li><a href="#getsnapshot">GetSnapshot</a></li>
<li><a href="#releasesnapshot">ReleaseSnapshot</a></li>
<li><a href="#getproperty">GetProperty</a></li>
<li><a href="#getappoximatesizes">GetAppoximateSizes</a></li>
<li><a href="#compactrange">CompactRange</a></li>
</ul>
</li>
<li><a href="#leveldb-%E7%9A%84%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B">leveldb 的文件类型</a><ul>
<li><a href="#log-%E6%96%87%E4%BB%B6">log 文件</a><ul>
<li><a href="#log-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F">log 文件格式</a></li>
<li><a href="#log-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%A5%BD%E5%A4%84">log 文件格式的好处</a></li>
<li><a href="#log-%E6%96%87%E4%BB%B6%E7%9A%84%E7%BC%BA%E7%82%B9%E5%B9%B6%E4%B8%8D%E6%98%AF">log 文件的缺点(并不是)</a></li>
<li><a href="#log-%E6%96%87%E4%BB%B6%E4%B8%BB%E8%A6%81%E6%8E%A5%E5%8F%A3">log 文件主要接口</a><ul>
<li><a href="#%E5%86%99-log">写 log</a></li>
<li><a href="#%E8%AF%BB-log">读 log</a></li>
</ul>
</li>
<li><a href="#%E4%B8%8E-log-%E6%96%87%E4%BB%B6%E9%85%8D%E5%A5%97%E7%9A%84-memtable">与 log 文件配套的 memtable</a><ul>
<li><a href="#%E7%BB%93%E6%9E%84">结构</a></li>
<li><a href="#%E7%94%A8%E9%80%94">用途</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sorted-table-%E6%96%87%E4%BB%B6">sorted table 文件</a><ul>
<li><a href="#sorted-table-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F">sorted table 文件格式</a></li>
<li><a href="#filter-meta-block">“filter” Meta Block</a></li>
<li><a href="#stats-meta-block">“stats” Meta Block</a></li>
<li><a href="#sorted-table-%E6%96%87%E4%BB%B6%E4%B8%BB%E8%A6%81%E6%8E%A5%E5%8F%A3">sorted table 文件主要接口</a><ul>
<li><a href="#sorted-table-%E6%96%87%E4%BB%B6%E8%AF%BB%E6%8E%A5%E5%8F%A3">sorted table 文件读接口</a></li>
<li><a href="#sorted-table-%E6%96%87%E4%BB%B6%E5%86%99%E6%8E%A5%E5%8F%A3">sorted table 文件写接口</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#manifest-%E6%96%87%E4%BB%B6">MANIFEST 文件</a><ul>
<li><a href="#%E4%B8%8E-manifest-%E7%9B%B8%E5%85%B3%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B-versionset">与 MANIFEST 相关的数据结构之 VersionSet</a></li>
<li><a href="#%E4%B8%8E-manifest-%E7%9B%B8%E5%85%B3%E7%9A%84-version-%E7%BB%93%E6%9E%84">与 MANIFEST 相关的 Version 结构</a></li>
<li><a href="#%E4%B8%8E-manifest-%E7%9B%B8%E5%85%B3%E7%9A%84-versionedit">与 MANIFEST 相关的 VersionEdit</a></li>
</ul>
</li>
<li><a href="#current-%E6%96%87%E4%BB%B6">CURRENT 文件</a></li>
<li><a href="#%E6%96%87%E4%BB%B6%E4%BD%8D%E7%BD%AE%E4%B8%8E%E5%91%BD%E5%90%8D">文件位置与命名</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<p>[toc]</p>
<h2><span id="从哪里着手分析-leveldb-实现">从哪里着手分析 leveldb 实现</span></h2><p>在了解了其基本使用以后, 如果想理解 leveldb 基本原理, 则有两个抓手. 第一个是  <code>include</code> 目录下的头文件, 尤其是 <code>db.h</code> , 第二个就是它的文件类型及其格式.</p>
<p>下面我们就从接口和文件两个方向来切入 leveldb 的设计与实现.</p>
<h2><span id="leveldb-常用的接口">leveldb 常用的接口</span></h2><h3><span id="open">Open</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打开一个名为 name 的数据库. </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 打开成功, 会把一个指向基于堆内存的数据库指针存储到 *dbptr, 同时返回 OK; 如果打开失败, </span></span><br><span class="line"><span class="comment"> * 存储 nullptr 到 *dbptr 同时返回一个错误状态. </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 调用者不再使用这个数据库时需要负责释放 *dbptr 指向的内存. </span></span><br><span class="line"><span class="comment"> * @param options 控制数据库行为和性能的参数配置</span></span><br><span class="line"><span class="comment"> * @param name 数据库名称</span></span><br><span class="line"><span class="comment"> * @param dbptr 存储指向堆内存中数据库的指针</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Status <span class="title">Open</span><span class="params">(<span class="keyword">const</span> Options&amp; options,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name,</span></span></span><br><span class="line"><span class="function"><span class="params">                    DB** dbptr)</span></span>;</span><br></pre></td></tr></table></figure>

<p>该方法在数据库启动时调用, 主要工作由 <code>leveldb::DBImpl::Recover</code> 方法完成, 后者主要做如下事情:</p>
<ul>
<li><ol>
<li>调用其 VersionSet 成员的 <code>leveldb::VersionSet::Recover</code> 方法该方法从磁盘读取 CURRENT 文件, 进而读取 MANIFEST 文件内容, 然后在内存建立 level 架构:</li>
</ol>
<ul>
<li>读取 CURRENT 文件(不存在则新建)找到最新的 MANIFEST 文件(不存在则新建)的名称</li>
<li>读取该 MANIFEST 文件内容与当前 Version 保存的 level 架构合并保存到一个新建的 Version 中, 然后将这个新的 version 作为当前的 version.</li>
<li>清理过期的文件</li>
<li>这一步我们可以打开全部 sstables, 但最好等会再打开</li>
<li>将 log 文件块转换为一个新的 level-0 sstable</li>
<li>将接下来的要写的数据写入一个新的 log 文件</li>
</ul>
</li>
<li><ol start="2">
<li>遍历数据库目录下全部文件. 筛选出 sorted table 文件, 验证 VersionSet 包含的 level 架构图有效性; 同时将全部 log 文件筛选换出来后续反序列化成 memtable. 恢复 log 文件时会按照从旧到新逐个 log 文件恢复, 这样新的修改会覆盖旧的, 如果对应 memtable 太大了, 将其转为 sorted table 文件写入磁盘, 同时将其对应的 table 对象放到 table_cache_ 缓存. 若发生 memtable 落盘表示 level 架构新增文件则将 save_manifest 标记为 true, 表示需要写变更日志到 manifest 文件. 恢复 log 文件主要由方法 <code>leveldb::DBImpl::RecoverLogFile</code> 负责完成.</li>
</ol>
</li>
</ul>
<h3><span id="put">Put</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将 &lt;key, value&gt; 对写入数据库, 成功返回 OK, 失败返回错误状态. </span></span><br><span class="line"><span class="comment"> * @param options 本次写操作相关的配置参数, 如果有需要可以将该参数中的 sync 置为 true, 不容易丢数据但更慢. </span></span><br><span class="line"><span class="comment"> * @param key Slice 类型的 key</span></span><br><span class="line"><span class="comment"> * @param value Slice 类型的 value</span></span><br><span class="line"><span class="comment"> * @return 返回类型为 Status</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Status <span class="title">Put</span><span class="params">(<span class="keyword">const</span> WriteOptions&amp; options,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">const</span> Slice&amp; key,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">const</span> Slice&amp; value)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>该方法主要依赖 <code>leveldb::DBImpl::Write</code> 实现.</p>
<h3><span id="delete">Delete</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从数据删除指定键为 key 的键值对. 如果 key 不存在不算错. </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param options 本次写操作相关的配置参数, 如果有需要可以将该参数中的 sync 置为 true, 不容易丢数据但更慢. </span></span><br><span class="line"><span class="comment"> * @param key 要删除数据项对应的 key</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Status <span class="title">Delete</span><span class="params">(<span class="keyword">const</span> WriteOptions&amp; options, <span class="keyword">const</span> Slice&amp; key)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>该方法主要依赖 <code>leveldb::DBImpl::Write</code> 实现.</p>
<h3><span id="write">Write</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对数据库进行批量更新写操作.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 该方法线程安全, 内部自带同步. </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param options 本次写操作相关的配置参数, 如果有需要可以将该参数中的 sync 置为 true, 不容易丢数据但更慢. </span></span><br><span class="line"><span class="comment"> * @param updates 要进行的批量更新操作</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Status <span class="title">Write</span><span class="params">(<span class="keyword">const</span> WriteOptions&amp; options, WriteBatch* updates)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>该方法是 <code>leveldb::DBImpl::Write</code> 原型.</p>
<p>针对调用 db 进行的写操作, 都会生成一个对应的 <code>struct leveldb::DBImpl::Writer</code>, 其封装了写入数据和写入进度. 新构造的 writer 会被放入一个队列. 循环检查, 若当前 writer 工作没完成并且不是队首元素, 则当前有其它 writer 在写, 挂起当前 writer 等待条件成熟. 当前 writer 如果被排在前面的 writer 给合并写入了, 那么它的 done 就被标记为完成了. 否则会被其它在写入的 writer 调用其 signal 将其唤醒执行写入工作.</p>
<p>当执行写入工作时(被前一个执行写入并完成工作的 writer 唤醒了), 首先确认是否为本次该 writer 写操作分配新的 log 文件, 如果需要则分配. 因为该 writer 成为队首 writer 了, 则它负责将队列前面若干 writers 的 batch 合并为一个(该工作由<code>leveldb::DBImpl::BuildBatchGroup</code> 负责完成), 注意, 被合并的 writers 不出队(待合并写入完成再出队, 具体见后面描述), 所以写 log 期间队首 writer 不变. 具体写入工作由 <code>leveldb::log::Writer::AddRecord</code> 负责, 就是将数据序列化为 record 写入 log 文件. 如果追加 log 文件成功,则将被追加的数据插入到内存中的 memtable 中. 待写入完毕, 该 writer 将参与前述 batch group 写入 log 文件的 writer 都取出来并设置为写入完成, 即将其出队, 将其 done 置为 true, 同时向其发送信号将其唤醒, 被唤醒后它会检查其 done 标识并返回. 最后唤醒队首 writer 执行下一个合并写入.</p>
<h3><span id="get">Get</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询键为 key 的数据项, 如果存在则将对应的 value 地址存储到第二个参数中. </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果 key 不存在, 第二个参数不变, 返回值为 IsNotFound Status. </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param options 本次读操作对应的配置参数</span></span><br><span class="line"><span class="comment"> * @param key 要查询的 key, Slice 引用类型</span></span><br><span class="line"><span class="comment"> * @param value 存储与 key 对应的值的指针, string 指针类型</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Status <span class="title">Get</span><span class="params">(<span class="keyword">const</span> ReadOptions&amp; options,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">const</span> Slice&amp; key, <span class="built_in">std</span>::<span class="built_in">string</span>* value)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>1 先查询当前在用的 memtable(具体工作由 <code>leveldb::MemTable::Get</code> 负责, 本质就是 SkipList 查询, 速度很快)</li>
<li>2 如果没有则查询正在转换为 sorted table 的 memtable 中寻找</li>
<li>3 如果没有则我们在磁盘上采用从底向上 level-by-level 的寻找目标 key. </li>
</ul>
<p>针对上述第 3 步, 具体由 db VersionSet 的当前 Version 负责, 因为该结构保存了 db 当前最新的 level 架构信息, 即每个 level 及其对应的文件列表和每个文件的键范围. 对应方法为 <code>leveldb::Version::Get</code>, 具体为:</p>
<ul>
<li>从低 level 向高 level 寻找. 由于 level 越低数据越新, 因此, 当我们在一个较低的 level 找到数据的时候, 不用在更高的 levels 找了.</li>
<li>由于 level-0 文件之间可能存在重叠, 而且针对同一个 key, 后产生的文件数据更新所以先将包含 key 的文件找出来按照文件号从大到小(对应文件从新到老)排序查找 key;</li>
<li>针对 level-1 及其以上 level, 由于每个 level 内文件之间不存在重叠, 于是在每个 level 中直接采用二分查找定位 key.</li>
</ul>
<p>另外需要注意的的是, 参数 <code>options</code> 可以配置一个快照, 快照对应了数据库历史上的一个操作序列号, 查询时仅查询不大于该序列号的操作范围. 针对同样的 key, 如果历史上有多次更新操作, 而用户想查找特定更新, 这就是实现途径. 如果没有配置快照选项, 默认采用当前最大序列号进行查询.</p>
<h3><span id="newiterator">NewIterator</span></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回基于堆内存的迭代器, 可以用该迭代器遍历整个数据库的内容. </span></span><br><span class="line"><span class="comment"> * 该函数返回的迭代器初始是无效的(在使用迭代器之前, 调用者必须在其上调用 Seek 方法). </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 当不再使用时, 调用者应该释放该迭代器对应的内存, 而且迭代器必须在数据库释放之前进行释放. </span></span><br><span class="line"><span class="comment"> * @param options 本次读操作对应的配置参数</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">virtual Iterator* NewIterator(<span class="keyword">const</span> ReadOptions&amp; options) = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>该方法负责将内存 memtable(可能有两个, 一个在写, 一个写完待存盘) 和磁盘 sorted table 文件全部数据结构串起来构造一个大一统迭代器, 可以遍历整个数据库.</p>
<p>上述工作其实是由 <code>leveldb::Iterator *leveldb::DBImpl::NewInternalIterator</code> 负责完成的. 该方法实现涉及到 leveldb 特别精巧的迭代器的实现. 这个单独可以写一篇文章来专门介绍. 这里大致说下处理流程:</p>
<ul>
<li>1 初始化一个列表</li>
<li>2 把当前 memtable 迭代器加入列表中</li>
<li>3 把待写盘 memtable 迭代器追加到列表中</li>
<li>4 将当前 version 维护的 level 架构中每个 sorted table 文件对应的迭代器追加到列表中. 针对 level-0 和其它 levels 处理方式不同.<ul>
<li>由于 level-0 文件之间可能存在重叠, 所以按照文件生成顺序(这极其重要, 其实就是按照 key 从小到大, 只有这样才能确保最后生成的迭代器能够从小到大按序遍历整个数据库) 为每个文件生成一个两级迭代器(<code>TwoLevelIterator</code>, 该结构巧妙地将索引块和数据块结合到了一起)追加到列表中. </li>
<li>针对 level-1 及其以上 level, 按照从低 level 到高 level(这极其重要, 原因同 level-0), 为每个 level 生成一个两级迭代器, 数据结构依然是 <code>TwoLevelIterator</code>, 不过这里把每个 level 的文件列表抽象成了第一级索引, 然后每个文件对应的 table 对象抽象层二级索引.</li>
</ul>
</li>
<li>最后将前述全部迭代器构成的迭代器列表再级联成一个大一统的迭代器 <code>MergingIterator</code>. 这其实也是一个两级迭代器, 第一级指向迭代器列表, 第二级是某个迭代器指向的内容的迭代器.</li>
</ul>
<p>最后返回给调用者的就是 <code>MergingIterator</code> 实例. 可以调用它的相关方法在整个数据库上寻找目标 key.</p>
<h3><span id="getsnapshot">GetSnapshot</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回当前 DB 状态的一个快照. </span></span><br><span class="line"><span class="comment"> * 使用该快照创建的全部迭代器将会都指向一个当前 DB 的一个稳定快照. </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 当不再使用该快照时, 调用者必须调用 ReleaseSnapshot 将其释放. </span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> Snapshot* <span class="title">GetSnapshot</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>用数据库当前最新的更新操作对应的序列号创建一个快照. 快照最核心的就是那个操作序列号, 因为查询时会把 用户提供的 key(我们叫做 user_key)和操作序列号一起构成一个 internal_key(数据库存储的 key 就是它), 针对 user_key 相等的情况比如针对 hello 这个 user_key Put 多次, 则每次序列号就不一样, 于是根据特定序列号可以查询到特定的那次 Put 写入的 value 值.</p>
<p>这个新生成的快照会被挂载到一个双向链表上, 用完后可以调用 <code>ReleaseSnapshot</code> 将其释放掉.</p>
<h3><span id="releasesnapshot">ReleaseSnapshot</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 释放一个之前获取的快照, 释放后, 调用者不能再使用该快照了. </span></span><br><span class="line"><span class="comment"> * @param snapshot 指向要释放的快照的指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ReleaseSnapshot</span><span class="params">(<span class="keyword">const</span> Snapshot* snapshot)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>从双向链表上删除指定的快照.</p>
<h3><span id="getproperty">GetProperty</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DB 实现可以通过该方法导出自身状态相关的信息. 如果提供的属性可以被 DB 实现理解, </span></span><br><span class="line"><span class="comment"> * 那么第二个参数将会存储该属性对应的当前值同时该方法返回 true, 其它情况该方法返回 false. </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 合法的属性名称包括: </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &quot;leveldb.num-files-at-level&lt;N&gt;&quot; - 返回 level &lt;N&gt; 的文件个数, 其中 &lt;N&gt; 是一个数字. </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &quot;leveldb.stats&quot; - 返回多行字符串, 描述该 DB 内部操作相关的统计数据. </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &quot;leveldb.sstables&quot; - 返回多行字符串, 描述构成该 DB 的全部 sstable 相关信息. </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &quot;leveldb.approximate-memory-usage&quot; - 返回被该 DB 使用的内存字节数近似值</span></span><br><span class="line"><span class="comment"> * @param property 要查询的属性名称</span></span><br><span class="line"><span class="comment"> * @param value 保存属性名称对应的属性值</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">GetProperty</span><span class="params">(<span class="keyword">const</span> Slice&amp; property, <span class="built_in">std</span>::<span class="built_in">string</span>* value)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>leveldb 实现在内部做了一些统计, 可以通过这个接口进行查询. 不过目前可查询状态不多, 具体如下:</p>
<ul>
<li>“leveldb.num-files-at-level<n>“ - 返回 level <n> 的文件个数, 其中 <n> 是一个 ASCII 格式的数字.</n></n></n></li>
<li>“leveldb.stats” - 返回多行字符串, 描述该 DB 内部操作相关的统计数据. </li>
<li>“leveldb.sstables” - 返回多行字符串, 描述构成该 DB 的全部 sstable 相关信息. </li>
<li>“leveldb.approximate-memory-usage” - 返回被该 DB 使用的内存字节数近似值</li>
</ul>
<h3><span id="getappoximatesizes">GetAppoximateSizes</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对于 [0, n-1] 中每个 i, 将位于 [range[i].start .. range[i].limit) </span></span><br><span class="line"><span class="comment"> * 中全部 keys 所占用文件系统空间近似大小存储到 sizes[i] 中. </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意, 如果数据被压缩过了, 那么返回的 sizes 存储的就是压缩后数据所占用文件系统空间大小. </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回结果可能不包含最近刚写入的数据所占用空间. </span></span><br><span class="line"><span class="comment"> * @param range 指定要查询一组 keys 范围</span></span><br><span class="line"><span class="comment"> * @param n range 和 sizes 两个数组的大小</span></span><br><span class="line"><span class="comment"> * @param sizes 存储查询到的每个 range 对应的文件系统空间近似大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">GetApproximateSizes</span><span class="params">(<span class="keyword">const</span> Range* range, <span class="keyword">int</span> n,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">uint64_t</span>* sizes)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>计算 range 包含的键区间在磁盘上占用的空间大小, 每个子区间占用会保存到 sizes 对应位置.</p>
<p>计算过程也很简单, 就是遍历 range 列表, 针对每个子区间起止 key, 去数据库中确认其大致字节偏移, 然后”止”-“始” 即为子区间占用空间的大致大小.</p>
<h3><span id="compactrange">CompactRange</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将 key 范围 [*begin,*end] 对应的底层存储压紧, 注意范围是左闭右闭. </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 尤其是, 压实过程会将已经删除或者复写过的数据会被丢弃, 同时会将数据</span></span><br><span class="line"><span class="comment"> * 重新安放以减少后续数据访问操作的成本. </span></span><br><span class="line"><span class="comment"> * 这个操作是为那些理解底层实现的用户准备的. </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果 begin==nullptr, 则从第一个键开始; 如果 end==nullptr 则到最后一个键为止. </span></span><br><span class="line"><span class="comment"> * 所以, 如果像下面这样做则意味着压紧整个数据库: </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * db-&gt;CompactRange(nullptr, nullptr);</span></span><br><span class="line"><span class="comment"> * @param begin 起始键</span></span><br><span class="line"><span class="comment"> * @param end 截止键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">CompactRange</span><span class="params">(<span class="keyword">const</span> Slice* begin, <span class="keyword">const</span> Slice* end)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>手动触发与目标键区间重叠的文件压实. 具体为:</p>
<ul>
<li>检查每个 level, 确认其包含的键区间释放与目标键区间有交集.</li>
<li>因为当前在写 memtable 可能与目标键区间有交集, 所以强制触发一次 memtable 压实(即将当前 memtable 文件转为 sorted table 文件并写入磁盘)并生成新 log 文件和对应的 memtable.</li>
<li>针对与目标键区间有交集的各个 level 触发一次手动压实</li>
</ul>
<p>具体压实过程后续会写一篇文章进行介绍.</p>
<h2><span id="leveldb-的文件类型">leveldb 的文件类型</span></h2><p>下面分别介绍 leveldb 最重要的几个文件类型.</p>
<h3><span id="log-文件">log 文件</span></h3><p>一个 log 文件(*.log)保存着最近一系列更新操作, 它相当于 leveldb 的 WAL(write-ahead log). 每个更新操作都被追加到当前的 log 文件中. 当 log 文件大小达到一个预定义的大小时(默认大约 4MB), 这个 log 文件就会被转换为一个 sorted table (见下文)然后一个新的 log 文件就会被创建以保存未来的更新操作. </p>
<p>当前 log 文件内容同时也会被记录到一个内存数据结构中(即 <code>memtable</code> ). 这个结构加上全部 sorted tables (*.ldb) 才是完整数据, 一起确保每个读操作都能查到当前最新. </p>
<h4><span id="log-文件格式">log 文件格式</span></h4><p>log 文件内容是一系列 blocks, 每个 block 大小为 32KB. 唯一的例外就是, log 文件末尾可能包含一个不完整的 block. </p>
<p>每个 block 由一系列 records 构成, 具体定义如下(熟悉编译原理的应该对下述写法不陌生): </p>
<pre><code>// 即 0 或多个 records, 0 或 1 个 trailer.
// 最大为 32768 字节.
block := record* trailer?
record :=
  // 下面提到的 type 和 data[] 的 crc32c 校验和, 小端字节序
  checksum: uint32
  // 下面的 data[] 的长度, 小端字节序
  length: uint16
  // 类型, FULL、FIRST、MIDDLE、LAST 取值之一
  type: uint8
  // 用户数据
  data: uint8[length]</code></pre>
<p>如果一个 block 剩余字节不超过 6 个(checksum 字段长度 + length 字段长度 + type 字段长度 = 7), 则不会再构造任何 record, 如前括号解释因为大小不合适. 这些剩余空间会被用于构造一个 trailer, reader 读取该文件时候会忽略之. </p>
<p>此外, 如果当前 block 恰好剩余 7 个字节(正好可以容纳 record 中的 checksum + length + type), 并且一个新的非 0 长度的 record 要被写入, 那么 writer 必须在此处写入一个 FIRST 类型的 record(但是 length 字段值为 0, data 字段为空. 用户数据 data 部分需要写入下个 block, 而且下个 block 起始还是要写入一个 header 不过其 type 为 middle)来填满该 block 尾部的 7 个字节, 然后在接下来的 blocks 中写入全部用户数据.</p>
<p>未来可能加入更多的 record 类型. Readers 可以跳过它们不理解的 record 类型, 也可以在跳过时进行报告. </p>
<pre><code>FULL == 1
FIRST == 2
MIDDLE == 3
LAST == 4</code></pre>
<p>FULL 类型的 record 包含了一个完整的用户 record 的内容. </p>
<p>FIRST、MIDDLE、LAST 这三个类型用于被分割成多个 fragments(典型的理由是某个 record 跨越了多个 block 边界) 的用户 record. FIRST 表示某个用户 record 的第一个 fragment, LAST 表示某个用户 record 的最后一个 fragment, MIDDLE 表示某个用户 record 的中间 fragments. </p>
<p>举例: 考虑下面一系列用户 records:<br>    A: 长度 1000<br>    B: 长度 97270<br>    C: 长度 8000<br><strong>A</strong> 会被作为 FULL 类型的 record 存储到第一个 block, 第一个 block 剩余空间为 32768 - 7 - 1000 = 31761; </p>
<p><strong>B</strong> 会被分割为 3 个 fragments: 第一个 fragment 占据第一个 block 剩余空间, 共存入 31761 - 7 = 31754, 剩余 65516; 第二个 fragment 占据第二个 block 的全部空间, 存入 32768 - 7 = 32761, 剩余 65516 - 32761 = 32755; 第三个 fragment 占据第三个 block 的起始空间共 7 + 32755 = 32762. 所以最后在第三个 block 剩下 32768 - 32762 = 6 个字节, 这几个字节会被填充 0 作为 trailer. </p>
<p><strong>C</strong> 将会被作为 FULL 类型的 record 存储到第四个 block 中. </p>
<p>MANIFEST 文件的格式同 log 文件, 只是记录的具体内容不同, 前者记录的针对 level 架构的文件级别变更(新增/删除), 后者记录的是用户数据 key-value 变更.</p>
<h4><span id="log-文件格式的好处">log 文件格式的好处</span></h4><p>log 文件格式的好处是(总结一句话就是容易划分边界): </p>
<ol>
<li>不必进行任何启发式地 resyncing(可以理解为寻找一个 block 的边界) —— 直接跳到下个 block 边界进行扫描即可, 因为每个 block 大小是固定的(32768 个字节, 除非文件尾部的 block 未写满). 如果数据有损坏, 直接跳到下个 block. 这个文件格式的附带好处是, 当一个 log 文件的部分内容作为一个 record 嵌入到另一个 log 文件时(即当一个逻辑 record 分为多个物理 records, 一部分 records 位于前一个 log 文件, 剩下 records 位于下个 log 文件), 我们不会分不清楚. </li>
<li>在估计出来的边界处做分割(比如为 mapreduce 应用)变得简单了: 找到下个 block 的边界, 如果起始是 MIDDLE 或者 LAST 类型的 record, 则跳过直到我们找到一个 FULL 或者 FIRST record 为止, 就可以在此处做分割, 一部分投递到一个计算任务, 另一部分(直到分界处)投递到另一个计算任务.</li>
</ol>
<h4><span id="log-文件的缺点并不是">log 文件的缺点(并不是)</span></h4><p>log 文件格式的缺点: </p>
<ul>
<li><ol>
<li>没有打包小的 records. 通过增加一个新的 record 类型可以解决这个问题, 所以这个问题是当前实现的不足而不是 log 格式的缺陷. </li>
</ol>
</li>
<li><ol start="2">
<li>没有压缩. 同样地, 这个也可以通过增加一个新的 record 类型来解决. </li>
</ol>
</li>
</ul>
<h4><span id="log-文件主要接口">log 文件主要接口</span></h4><p>下面介绍下 log 文件的读写实现.</p>
<h5><span id="写-log">写 log</span></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">leveldb::Status leveldb::<span class="built_in">log</span>::Writer::AddRecord(<span class="keyword">const</span> leveldb::Slice &amp;slice)</span><br></pre></td></tr></table></figure>

<p>该接口做的事情就是把外部传入的 Slice 封装成若干 records 追加到 log 文件中.</p>
<p>该方法会被 <code>leveldb::Status leveldb::DBImpl::Write(const leveldb::WriteOptions &amp;options, leveldb::WriteBatch *my_batch)</code> 调用以响应用户的写操作. <code>DBImpl</code> 是 <code>DB</code> 的派生类, 其 <code>Put</code> 和 <code>Delete</code> 方法真正工作是由派生类的 <code>Write</code> 负责的.</p>
<h5><span id="读-log">读 log</span></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> leveldb::<span class="built_in">log</span>::Reader::ReadRecord(leveldb::Slice *record, <span class="built_in">string</span> *scratch)</span><br></pre></td></tr></table></figure>

<p>该方法负责从 log 文件读取内容并反序列化为 Record. 该方法会在 db 的 <code>Open</code> 方法中调用, 负责将磁盘上的 log 文件转换为内存中 memtable. 其它数据库恢复场景也会用到该方法.</p>
<h4><span id="与-log-文件配套的-memtable">与 log 文件配套的 memtable</span></h4><p>memtable 可以看作是 log 文件的内存形式, 但是格式不同.</p>
<h5><span id="结构">结构</span></h5><p>它的本质就是一个 SkipList.</p>
<h5><span id="用途">用途</span></h5><p>我们已经知道, 每个 log 文件在内存有一个对应的 memtable, 它和正在压实的 memtable 以及磁盘上的各个 level 包含的文件构成了数据全集. 所以当调用 DB 的 <code>Get</code> 方法查询某个 key 的时候, 具体步骤是这样的(具体实现位于 <code>leveldb::Status leveldb::Version::Get(const leveldb::ReadOptions &amp;options, const leveldb::LookupKey &amp;k, string *value, leveldb::Version::GetStats *stats)</code>, DB 的 <code>Get</code> 方法会调用前述实现.):</p>
<ul>
<li>1 先查询当前在用的 memtable, 查到返回, 未查到下一步</li>
<li>2 查询正在转换为 sorted table 的 memtable 中寻找, 查到返回, 未查到下一步 </li>
<li>3 在磁盘上采用从底向上 level-by-level 的寻找目标 key. <ul>
<li>由于 level 越低数据越新, 因此, 当我们在一个较低的 level 找到数据的时候, 不用在更高的 levels 找了.</li>
<li>由于 level-0 文件之间可能存在重叠, 而且针对同一个 key, 后产生的文件数据更新所以先将包含 key 的文件找出来按照文件号从大到小(对应文件从新到老)排序查找 key; 针对 level-1 及其以上 level, 由于每个 level 内文件之间不存在重叠, 于是在每个 level 中直接采用二分查找定位 key.</li>
</ul>
</li>
</ul>
<h3><span id="sorted-table-文件">sorted table 文件</span></h3><p>sorted table(*.ldb) 文件就是 leveldb 的数据库文件了. 每一个 level 都对应一组有序的 sorted table 文件. 每个 sorted table 文件保存着按 key 排序的一系列数据项. 每个数据项要么是一个与某个 key 对应的 value, 要么是某个 key 的删除标记. (删除标记其它地方又叫墓碑消息, 用于声明时间线上在此之前的同名 key 对应的记录都失效了, 后台线程负责对这类记录进行压实, 即拷贝到另一个文件时物理删除这类记录.). 注意, leveldb 是一个 append 类型而非 MySQL 那种 in-place 修改的数据库.</p>
<p>sorted tables 文件被组织成一系列 levels. 一个 log 文件生成的对应 sorted table 文件会被放到一个特殊的 <strong>young</strong> level(也被叫做 level-0). 当 young 文件数目超过某个阈值(当前是 4), 全部 young 文件就会和 level-1 与之重叠的全部文件进行合并, 进而生成一系列新的 level-1 文件(每 2MB 数据就会生成一个新的 level-1 文件). </p>
<p>level-0 的文件之间可能存在键区间重叠, 但是其它每层 level 内部文件之间是不存在重叠情况的. 我们下面来说下 level-1 及其以上的 level 的文件如何合并. 当 level-L (L &gt;= 1)的文件总大小超过了 $10^L$ MB(即 level-1 超过了 10MB, level-2 超过了 100MB, …), 此时一个 level-L 文件就会和 level-(L+1) 中与自己键区间重叠的全部文件进行合并, 然后为 level-(L+1) 生成一组新的文件. 这些合并操作可以实现将 young level 中新的 updates 一点一点搬到最高的那层 level, 这个迁移过程使用的都是块读写(最小化了昂贵的 seek 操作的时间消耗). </p>
<h4><span id="sorted-table-文件格式">sorted table 文件格式</span></h4><p>leveldb sorted table (又叫 sstable) 文件主要包含五个部分, 即多个 data blocks, 多个 meta blocks, 一个 metaindex block, 一个 index block 以及一个 footer, 具体格式如下: </p>
<pre><code>&lt;beginning_of_file&gt;
[data block 1]
[data block 2]
...
[data block N]
[meta block 1]
...
[meta block K]
[metaindex block]
[index block]
[Footer]        (fixed size; starts at file_size - sizeof(Footer))
&lt;end_of_file&gt;</code></pre>
<p>不像 kafka 存储结构数据文件和索引文件是各自独立的(在查询时索引文件用了根据具体 key 定位是哪个数据文件), 该文件把索引和数据保存到了一个文件中. 每次从文件查询数据时会先查询索引, 索引是指向数据的指针, 具体叫做 BlockHandle, 包含着下述信息: </p>
<pre><code>// 对应 block 起始位置在文件中的偏移量
offset: varint64
// 对应 block 的大小
size:   varint64</code></pre>
<p>如果你没用过 protobuf 之类的二进制编解码协议, 可能对 varint64 不太熟悉, 可以参考这里 <a target="_blank" rel="noopener" href="https://developers.google.com/protocol-buffers/docs/encoding#varints">varints</a> 了解一下. 本质就是对数据类型进行(二次)无损编码, 使其更加紧凑, 可以节省带宽或者存储空间.</p>
<p>下面详细解释下上面提到的文件格式: </p>
<ul>
<li><ol>
<li>文件里存的是一系列 key/value 对, 而且按照 key 排过序了, 同时被划分到了多个 blocks 中. 这些 blocks 从文件起始位置开始一个接一个. 每个 data block 组织形式在 <code>block_builder.cc</code> 定义, 用户可以选择对 data block 进行压缩. </li>
</ol>
</li>
<li><ol start="2">
<li>全部 data blocks 之后是一组 meta blocks. 已经支持的 meta block 类型见下面描述, 将来可能会加入更多的类型. 每个 meta block 组织形式在 <code>block_builder.cc</code> 定义, 同样地, 用户可以选择对其进行压缩. </li>
</ol>
</li>
<li><ol start="3">
<li>全部 meta blocks 后是一个 metaindex block. 每个 meta block 都有一个对应的 entry 保存在该部分, 其中 key 就是某个 meta block 的名字, value 是一个指向该 meta block 的 BlockHandle. </li>
</ol>
</li>
<li><ol start="4">
<li>紧随 metaindex block 之后是一个 index block. 针对每个 data block 都有一个对应的 entry 包含在该部分, 其中 key 为大于等于对应 data block 最后(也是最大的, 因为排序过了)一个 key 同时小于接下来的 data block 第一个 key 的字符串; value 是指向一个对应 data block 的 BlockHandle. </li>
</ol>
</li>
<li><ol start="5">
<li><p>在每个文件的末尾是一个固定长度的 footer, 固定长度的好处就是读取文件时, 用 file size 减去这个固定长度就能定位到 footer 起始偏移, 然后就可以解析了. 它包含了一个指向 metaindex block 的 BlockHandle 和一个指向 index block 的 BlockHandle 以及一个 magic number. 具体格式如下:</p>
<pre><code> // 指向 metaindex 的 BlockHandle
 metaindex_handle: char[p];     
 // 指向 index 的 BlockHandle
 index_handle:     char[q];     
 // 用于维持固定长度的 padding 0,
 // (其中 40 == 2*BlockHandle::kMaxEncodedLength)
 padding:          char[40-p-q];
 // 具体内容为 0xdb4775248b80fb57 (小端字节序)
 magic:            fixed64;     </code></pre>
</li>
</ol>
</li>
</ul>
<h4><span id="filter-meta-block">“filter” Meta Block</span></h4><p>如果打开(创建)数据库的时候指定了一个 <code>FilterPolicy</code>, 那么一个 filter block 就会被存储到每个 sstable 中. metaindex block 包含了一个 entry, 它是从 <code>filter.&lt;Name&gt;</code> 到 filter block 的 BlockHandle 的映射. 其中, <code>&lt;Name&gt;</code> 是一个由 filter policy 的 <code>Name()</code>方法返回的字符串. </p>
<p>filter block 保存着一系列 filters, 其中 filter i 包含了方法</p>
<pre><code class="c++">void leveldb::FilterPolicy::CreateFilter(const Slice *keys, int n, string *dst) const</code></pre>
<p>针对入参 keys 的计算结果(存储在输出型参数 <code>dst</code>). 参数 keys 属于一个 data block, 该 data block 对应的文件偏移量落在下面的范围里: </p>
<pre><code>[ i*base ... (i+1)*base-1 ]</code></pre>
<p>当前, 上面的 base 是 2KB. 举个例子, 如果 block X 和 block Y 起始地址落在 <code>[ 0KB .. 2KB ]</code> 范围内, 则 X 和 Y 中的全部 keys 将会在调用 <code>FilterPolicy::CreateFilter()</code> 时被转换为一个 filter, 然后这个 filter 会作为一个(为啥是第一个, 因为 X、Y 起始地址落在第一个地址空间 <code>[ 0KB .. 2KB ]</code> 里) filter 被保存在 filter block 中. (用大白话再说一遍, 每个 FilterPolicy 都有一个唯一的名字, 在 metaindex block 通过这个名字就能找到对应的 filter block 了. 而 filter block 存的就是用这个 FilterPolicy 构造的一系列 filters, 为啥是一系列呢？因为 data blocks 太多了, 所以分了区间, 每几个 data blocks 对应一个 filter, 具体几个根据上面那个带 base 的公式来算. 再说说 filter 是怎么回事. data block 保存的不是键值对构成的 records 嘛, 根据前面说的键区间限制, 把每几个 blocks 的全部键根据某个 FilterPolicy 算一下就得到了一个 filter, 然后把这个 filter 保存到了 filter block 的第 i 个位置. )</p>
<p>具有 N 个 filter 的 filter block 格式如下: </p>
<pre><code>[filter 0]
[filter 1]
[filter 2]
...
[filter N-1]
// 下面的 [offset of filter X] 布局其实不太准确, 准确地
// 说, 除了 [offset of filter 0], 其它的都可能多出现一次.
// 具体原因见 leveldb::FilterBlockBuilder::GenerateFilter() 的疑问.
[offset of filter 0]                  : 4 bytes
[offset of filter 1]                  : 4 bytes
[offset of filter 2]                  : 4 bytes
...
[offset of filter N-1]                : 4 bytes
// 上面 [offset of filter 0] 相对于 filter block 首地址的相对偏移量, 
// 基于该值可以将 fiter 部分和 filter offset 部分分辨出来.
[offset of beginning of offset array] : 4 bytes
// base 以 2 为底的对数, 目前 base 是 2048, 则这里就是 11
lg(base)                              : 1 byte</code></pre>
<p>其中, 位于 filter block 尾部的 offset 数组可以使得我们快速定位到某个 filter. </p>
<p>由 <code>leveldb::Slice leveldb::FilterBlockBuilder::Finish()</code> 负责构造上述格式, 然后由 <code>leveldb::FilterBlockReader::FilterBlockReader()</code> 构造方法负责解析上述格式.</p>
<h4><span id="stats-meta-block">“stats” Meta Block</span></h4><p>下面的 meta block 保存着一组统计信息. key 是统计量的名称, value 是具体的统计值. </p>
<pre><code>data size
index size
key size (uncompressed)
value size (uncompressed)
number of entries
number of data blocks</code></pre>
<p>遗憾的是, 目前这个还没实现, 🤭.</p>
<h4><span id="sorted-table-文件主要接口">sorted table 文件主要接口</span></h4><p>下面说明一下 sorted table 文件主要的操作接口, 主要是读与写.</p>
<h5><span id="sorted-table-文件读接口">sorted table 文件读接口</span></h5><p>完成该工作的是 <code>class leveldb::Table</code>, 该类是对 sorted table 文件的抽象, 负责对 sorted table 文件进行读操作.</p>
<p>具体底层存储由 helper 类 <code>struct leveldb::Table::Rep</code> 负责.</p>
<p>打开一个 sstable 文件的入口为 <code>leveldb::Status leveldb::Table::Open</code>, 该方法依次动作为:</p>
<ul>
<li>1 读取文件末尾固定长度的 footer (具体长度为两个 BlockHandle 最大长度 + 固定的 8 字节魔数)</li>
<li>2 解析 footer 从而得到 index block 偏移量和大小以及 meta block 偏移量和大小.</li>
<li>3 将解析出来的 index block 放到 Table 对象中, 通过输出型参数返回.</li>
</ul>
<p>从外部(这里强调外部, 是因为还有一个私有方法 <code>leveldb::Status leveldb::Table::InternalGet</code> 可以访问 Table 对象内容)打开文件后如果要访问其内容, 需要一个迭代器, 该工作通过 <code>leveldb::Iterator *leveldb::Table::NewIterator</code> 完成. 返回的迭代器为一个 <code>leveldb::&lt;unnamed&gt;::TwoLevelIterator</code>, 该迭代器处于匿名的命名空间所以未直接对外暴露, 仅能通过返回的指针访问其从 <code>class leveldb::Iterator</code> 继承的方法. 该迭代器设计精巧, 会单独写文章介绍.</p>
<h5><span id="sorted-table-文件写接口">sorted table 文件写接口</span></h5><p>完成该工作的是 <code>class leveldb::TableBuilder</code>, 该类负责构造 sstable 文件构造.</p>
<p>主要方法有以下两个:</p>
<ul>
<li><code>void BlockBuilder::Add(const Slice&amp; key, const Slice&amp; value)</code> 负责向 TableBuilder 对象添加 (key, value), 该工作主要由 <code>class leveldb::BlockBuilder::Add()</code> 方法完成.</li>
<li><code>void leveldb::TableBuilder::Finish()</code> 负责将整个 Table 序列化为一个 sstable 文件并写入磁盘, 具体写入顺序为:<ul>
<li>写 data blocks</li>
<li>写 meta blocks(目前仅有过滤器)</li>
<li>写 meta-index block</li>
<li>写 data-index block</li>
<li>写 footer</li>
</ul>
</li>
</ul>
<h3><span id="manifest-文件">MANIFEST 文件</span></h3><p>MANIFEST 文件可以看作 leveldb 存储元数据的地方. 它列出了每一个 level 及其包含的全部 sorted table 文件, 每个 sorted table 文件对应的键区间, 以及其它重要的元数据. 每当重新打开数据库的时候, 就会创建一个新的 MANIFEST 文件(文件名中嵌有一个新生成的数字). MANIFEST 文件被格式化成形同 log 文件的格式, 针对它所服务的数据的变更都会被追加到该文件后面. 比如每当某个 level 发生文件新增或者删除操作时, 就会有一条日志被追加到 MANIFEST 中. </p>
<p>MANIFEST 文件在实现时又叫 descriptor 文件, 文件格式同 log 文件, 所以写入/读取方法就复用了. 其每条日志就是一个序列化后的 <code>leveldb::VersionEdit</code>. 每次针对 level 架构有文件增删时都要写日志到 manifest 文件.</p>
<h4><span id="与-manifest-相关的数据结构之-versionset">与 MANIFEST 相关的数据结构之 VersionSet</span></h4><p>每个 db 都有一个 <code>class leveldb::VersionSet</code> 实例, 它保存了 db 当前的 level 架构视图(具体存储结构为其 Version 成员). MANIFEST 文件可以看作是它所维护的信息的反映. 它的重要方法有:</p>
<ul>
<li><code>VersionSet::Recover</code> 负责在打开数据库时将 MANIFEST 文件反序列化构造 level 架构视图, 这个过程会依赖 VersionEdit 类.</li>
<li><code>VersionSet::LogAndApply</code> 负责将当前 VersionEdit 和当前 Version 进行合并, 然后序列化为一条日志记录到 MANIFEST 文件. 最后把新的 version 替换当前 version.</li>
</ul>
<h4><span id="与-manifest-相关的-version-结构">与 MANIFEST 相关的 Version 结构</span></h4><p><code>class leveldb::Version</code> 是 leveldb 数据库 level 架构的内存表示, 它存储了每一个 level 及其全部的文件信息(文件名, 键范围等等). 每次调用 db 的 Get 方法在 memtable 找不到目标 key 时就会到各个 level 的文件去搜寻, 这个搜寻过程所依赖的就是数据库 VersionSet(下面介绍) 保存的当前 Version 存储的 level 架构信息进行的, 具体实现见 <code>leveldb::Version::Get</code> 方法.</p>
<p>当条件满足时, VersionSet 会将当前 Version 和当前 VesionEdit 合并生成一个新的 Version 替换当前 Version.</p>
<h4><span id="与-manifest-相关的-versionedit">与 MANIFEST 相关的 VersionEdit</span></h4><p>MANIFEST 文件的每一条日志就是一个序列化的 <code>class leveldb::VersionEdit</code>. 它可以看作一个 on-fly 的 Version. 它会记录 db 运行过程中删除的文件列表和新增的文件列表.</p>
<h3><span id="current-文件">CURRENT 文件</span></h3><p>CURRENT 文件是一个简单的文本文件. 由于每次重新打开数据库都会生成一个 MANIFEST 文件, 所以需要一个地方记录最新的 MANIFEST 文件是哪个, CURRENT 就干这个事情, 它相当于一个指针, 其内容即是当前最新的 MANIFEST 文件的名称. </p>
<h3><span id="文件位置与命名">文件位置与命名</span></h3><p>各类型文件位置与命名如下:</p>
<pre><code>dbname/CURRENT
dbname/LOCK
dbname/LOG
dbname/LOG.old
dbname/MANIFEST-[0-9]+
dbname/[0-9]+.(log|sst|ldb)</code></pre>
<p>其中 dbname 为用户指定.</p>
<p>–End–</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://chielungcheung.github.io/2020/09/11/leveldb-annotations-0-usage-and-examples/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chienlung Cheung">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="programatrix">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/11/leveldb-annotations-0-usage-and-examples/" class="post-title-link" itemprop="url">Leveldb 原理详解系列之零: 基本介绍与使用举例</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-11 21:13:08" itemprop="dateCreated datePublished" datetime="2020-09-11T21:13:08+00:00">2020-09-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-25 06:37:30" itemprop="dateModified" datetime="2020-09-25T06:37:30+00:00">2020-09-25</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2020/09/11/leveldb-annotations-0-usage-and-examples/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/09/11/leveldb-annotations-0-usage-and-examples/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!-- toc -->

<ul>
<li><a href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D">基本介绍</a><ul>
<li><a href="#%E7%89%B9%E6%80%A7">特性</a></li>
<li><a href="#%E5%B1%80%E9%99%90%E6%80%A7">局限性</a></li>
<li><a href="#%E6%80%A7%E8%83%BD">性能</a><ul>
<li><a href="#%E6%B5%8B%E8%AF%95%E9%85%8D%E7%BD%AE">测试配置</a></li>
<li><a href="#%E5%86%99%E6%80%A7%E8%83%BD">写性能</a></li>
<li><a href="#%E8%AF%BB%E6%80%A7%E8%83%BD">读性能</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%BD%BF%E7%94%A8%E4%B8%BE%E4%BE%8B">使用举例</a><ul>
<li><a href="#%E6%9E%84%E5%BB%BA">构建</a></li>
<li><a href="#%E5%A4%B4%E6%96%87%E4%BB%B6%E4%BB%8B%E7%BB%8D">头文件介绍</a></li>
<li><a href="#%E6%89%93%E5%BC%80%E6%88%96%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93">打开(或新建)一个数据库</a></li>
<li><a href="#status-%E7%B1%BB%E5%9E%8B">Status 类型</a></li>
<li><a href="#%E5%85%B3%E9%97%AD%E6%95%B0%E6%8D%AE%E5%BA%93">关闭数据库</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BB%E5%86%99">数据库读写</a></li>
<li><a href="#%E5%8E%9F%E5%AD%90%E6%9B%B4%E6%96%B0">原子更新</a></li>
<li><a href="#%E5%90%8C%E6%AD%A5%E5%86%99%E6%93%8D%E4%BD%9C">同步写操作</a></li>
<li><a href="#%E5%B9%B6%E5%8F%91">并发</a></li>
<li><a href="#%E8%BF%AD%E4%BB%A3%E6%95%B0%E6%8D%AE%E5%BA%93">迭代数据库</a></li>
<li><a href="#%E5%BF%AB%E7%85%A7">快照</a></li>
<li><a href="#slice-%E5%88%87%E7%89%87">Slice 切片</a></li>
<li><a href="#%E6%AF%94%E8%BE%83%E5%99%A8">比较器</a><ul>
<li><a href="#%E5%90%8E%E5%90%91%E5%85%BC%E5%AE%B9%E6%80%A7">后向兼容性</a></li>
</ul>
</li>
<li><a href="#%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98">性能调优</a><ul>
<li><a href="#block-%E5%A4%A7%E5%B0%8F">Block 大小</a></li>
<li><a href="#%E5%8E%8B%E7%BC%A9">压缩</a></li>
<li><a href="#%E7%BC%93%E5%AD%98">缓存</a></li>
<li><a href="#key-%E7%9A%84%E5%B8%83%E5%B1%80%E8%AE%BE%E8%AE%A1">Key 的布局设计</a></li>
<li><a href="#%E8%BF%87%E6%BB%A4%E5%99%A8">过滤器</a></li>
</ul>
</li>
<li><a href="#%E6%A0%A1%E9%AA%8C%E5%92%8C">校验和</a></li>
<li><a href="#%E8%BF%91%E4%BC%BC%E7%A9%BA%E9%97%B4%E5%A4%A7%E5%B0%8F">近似空间大小</a></li>
<li><a href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">环境变量</a></li>
<li><a href="#%E7%A7%BB%E6%A4%8D%E6%80%A7">移植性</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<p><strong>Leveldb</strong> 是一个高速 KV 数据库, 它提供了一个持久性的 KV 存储. 其中 keys 和 values 都是随机字节数组, 并且存储时根据用户指定的比较函数对 keys 进行排序. </p>
<p>它由 Google 开发的, 其作者为大名鼎鼎的 Sanjay Ghemawat (<a href="mailto:&#115;&#97;&#110;&#106;&#x61;&#121;&#x40;&#x67;&#111;&#111;&#x67;&#108;&#101;&#x2e;&#x63;&#111;&#109;">&#115;&#97;&#110;&#106;&#x61;&#121;&#x40;&#x67;&#111;&#111;&#x67;&#108;&#101;&#x2e;&#x63;&#111;&#109;</a>) 和 Jeff Dean (<a href="mailto:&#x6a;&#x65;&#x66;&#102;&#x40;&#x67;&#x6f;&#x6f;&#x67;&#108;&#x65;&#x2e;&#99;&#x6f;&#109;">&#x6a;&#x65;&#x66;&#102;&#x40;&#x67;&#x6f;&#x6f;&#x67;&#108;&#x65;&#x2e;&#99;&#x6f;&#109;</a>). 感谢他们对人类的贡献.</p>
<h1><span id="基本介绍">基本介绍</span></h1><p>该部分主要介绍 leveldb 的功能, 局限性以及性能等.</p>
<h2><span id="特性">特性</span></h2><ul>
<li>keys 和 values 都可以是随机的字节数组. </li>
<li>数据被按照 key 的顺序进行存储. </li>
<li>调用者可以提供一个定制的比较函数来覆盖默认的比较器. </li>
<li>基础操作有 <code>Put(key,value)</code>, <code>Get(key)</code>, <code>Delete(key)</code>. </li>
<li>多个更改可以在一个原子批处理中一起生效. </li>
<li>用户可以创建一个瞬时快照来获取数据的一致性视图. </li>
<li>支持针对数据的前向和后向遍历. </li>
<li>数据通过 <a target="_blank" rel="noopener" href="http://google.github.io/snappy/">Snappy</a> 压缩程序库自动压缩. </li>
<li>与外部交互的操作都被抽象成了接口(如文件系统操作等), 所以用户可以根据接口定制自己期望的操作系统交互行为. </li>
</ul>
<h2><span id="局限性">局限性</span></h2><ul>
<li>LevelDB 不是 SQL 数据库. 它没有关系数据模型, 不支持 SQL 查询, 也不支持索引. </li>
<li>同时只能有一个进程(可能是具有多线程的进程)访问一个特定的数据库. </li>
<li>该程序库没有内置基于网络的 CS 架构, 有需求的用户可以自己封装. </li>
</ul>
<h2><span id="性能">性能</span></h2><p>下面是通过运行 db_bench 程序得出的性能测试报告. </p>
<h3><span id="测试配置">测试配置</span></h3><p>我们使用的是一个包含一百万数据项的数据库,<br>其中 key 是 16 字节, value 是 100 字节, value 压缩后大约是原来的一半, 测试配置如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LevelDB:    version 1.1</span><br><span class="line">Date:       Sun May  1 12:11:26 2011</span><br><span class="line">CPU:        4 x Intel(R) Core(TM)2 Quad CPU    Q6600  @ 2.40GHz</span><br><span class="line">CPUCache:   4096 KB</span><br><span class="line">Keys:       16 bytes each</span><br><span class="line">Values:     100 bytes each (50 bytes after compression)</span><br><span class="line">Entries:    1000000</span><br><span class="line">Raw Size:   110.6 MB (estimated)</span><br><span class="line">File Size:  62.9 MB (estimated)</span><br></pre></td></tr></table></figure>

<h3><span id="写性能">写性能</span></h3><p>“fill” 基准测试创建了一个全新的数据库, 以顺序(下面 “seq” 结尾者)或者随机(下面 “random” 结尾者)方式写入. “fillsync” 基准测试每次写操作都将数据从操作系统刷到磁盘; 其它的操作会将数据保存在系统中一段时间. “overwrite” 基准测试做随机写, 这些操作会更新数据库中已有的键. </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fillseq      :       1.765 micros/op;   62.7 MB/s</span><br><span class="line">fillsync     :     268.409 micros/op;    0.4 MB/s (10000 ops)</span><br><span class="line">fillrandom   :       2.460 micros/op;   45.0 MB/s</span><br><span class="line">overwrite    :       2.380 micros/op;   46.5 MB/s</span><br></pre></td></tr></table></figure>
<p>上述每个 “op” 对应一个 key/value 对的写操作. 也就是说, 一个随机写基准测试每秒大约进行四十万次写操作(1,000,000/2.46). </p>
<p>每个 “fillsync” 操作时间消耗(大约 0.3 毫秒)少于一次磁盘寻道(大约 10 毫秒). 我们怀疑这是因为磁盘本身将更新操作缓存到了内存, 并且在数据真正落盘前返回响应. 该方式是否安全取决于断电后磁盘是否有备用电力将数据落盘. </p>
<h3><span id="读性能">读性能</span></h3><p>我们分别给出正向顺序读、反向顺序读的性能以及随机查询的性能指标. 注意, 基准测试创建的数据库很小. 因此该性能报告描述的是 leveldb 的全部数据集能放入到内存的场景. 如果数据不在操作系统缓存中, 读取一点数据的性能消耗主要在于一到两次的磁盘寻道. 写性能基本不会受数据集是否能放入内存的影响. </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">readrandom  : 16.677 micros/op;  (approximately 60,000 reads per second)</span><br><span class="line">readseq     :  0.476 micros/op;  232.3 MB/s</span><br><span class="line">readreverse :  0.724 micros/op;  152.9 MB/s</span><br></pre></td></tr></table></figure>
<p>LevelDB 会在后台压实底层的数据来改善读性能. 上面列出的结果是在经过一系列随机写操作后得出的. 如果经过压实(通常是自动触发), 那么上述指标会更好. </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">readrandom  : 11.602 micros/op;  (approximately 85,000 reads per second)</span><br><span class="line">readseq     :  0.423 micros/op;  261.8 MB/s</span><br><span class="line">readreverse :  0.663 micros/op;  166.9 MB/s</span><br></pre></td></tr></table></figure>

<p>读操作消耗高的地方有一些来自重复解压从磁盘读取的数据块. 如果我们能提供足够的缓存给 leveldb 来将<br>解压后的数据保存在内存中, 读性能会进一步改善: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">readrandom  : 9.775 micros/op;  (approximately 100,000 reads per second before compaction)</span><br><span class="line">readrandom  : 5.215 micros/op;  (approximately 190,000 reads per second after compaction) </span><br></pre></td></tr></table></figure>

<h1><span id="使用举例">使用举例</span></h1><p>下面从构建和头文件介绍开始, 对 leveldb 的基本使用进行介绍.</p>
<h2><span id="构建">构建</span></h2><p>该工程开箱支持 CMake. </p>
<p>所以构建起来超简单: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">$ cmake -DCMAKE_BUILD_TYPE=Release .. &amp;&amp; cmake --build .</span><br><span class="line">$ sudo make install</span><br></pre></td></tr></table></figure>

<p>更多高级用法请请参照 CMake 文档和本项目的 CMakeLists.txt. </p>
<h2><span id="头文件介绍">头文件介绍</span></h2><p>LevelDB 对外的接口都包含在 include/*.h 中. 除了该目录下的文件, 用户不应该依赖其它目录下任何文件. </p>
<ul>
<li><p><strong>include/db.h</strong>: 主要的接口在这, 使用 leveldb 从这里开始. </p>
</li>
<li><p><strong>include/options.h</strong>: 使用 leveldb 过程各种操作包括读写有关的控制参数. </p>
</li>
<li><p><strong>include/comparator.h</strong>: 比较函数的抽象, 如果你想用逐字节比较 key 那么可以直接使用默认的比较器. 如果你想定制排序逻辑(如处理不同的字符编解码等)可以定制自己的比较函数. </p>
</li>
<li><p><strong>include/iterator.h</strong>: 迭代数据的接口. 你可以从一个 DB 对象获取到一个迭代器. </p>
</li>
<li><p><strong>include/write_batch.h</strong>: 原子地应用多个更新到一个数据库. </p>
</li>
<li><p><strong>include/slice.h</strong>: 类似 string, 维护着指向字节数组的一个指针和相应长度. </p>
</li>
<li><p><strong>include/status.h</strong>: 许多公共接口都会返回 <code>Status</code>, 用于指示成功或其它各种错误. </p>
</li>
<li><p><strong>include/env.h</strong>: 操作系统环境的抽象. 在 <code>util/env_posix.cc</code> 中有一个该接口的 posix 实现. </p>
</li>
<li><p><strong>include/table.h, include/table_builder.h</strong>: 底层的模块, 大多数客户端可能不会直接用到. </p>
</li>
</ul>
<h2><span id="打开或新建一个数据库">打开(或新建)一个数据库</span></h2><p>leveldb 数据库都有一个名字, 该名字对应了文件系统上一个目录, 而且该数据库内容全都存在该目录下. 下面的例子显示了如何打开一个数据库以及在必要情况下创建之. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;leveldb/db.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">leveldb::DB* db;</span><br><span class="line">leveldb::Options options;</span><br><span class="line">options.create_if_missing = <span class="literal">true</span>;</span><br><span class="line">leveldb::Status status = leveldb::DB::Open(options, <span class="string">&quot;/tmp/testdb&quot;</span>, &amp;db);</span><br><span class="line">assert(status.ok());</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>如果你想在数据库已存在的时候触发一个异常, 将下面这行加到 <code>leveldb::DB::Open</code> 调用之前: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">options.error_if_exists = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<h2><span id="status-类型">Status 类型</span></h2><p>你可能注意到上面的 <code>leveldb::Status</code> 类型了. leveldb 中大部分方法在遇到错误的时候会返回该类型的值. 你可以检查它是否为 ok, 然后打印关联的错误信息即可: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">leveldb::Status s = ...;</span><br><span class="line"><span class="keyword">if</span> (!s.ok()) <span class="built_in">cerr</span> &lt;&lt; s.ToString() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<h2><span id="关闭数据库">关闭数据库</span></h2><p>当数据库不再使用的时候, 像下面这样直接删除数据库对象就可以了: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">... open the db as described above ...</span><br><span class="line">... <span class="keyword">do</span> something with db ...</span><br><span class="line"><span class="keyword">delete</span> db;</span><br></pre></td></tr></table></figure>

<p>非常简单是不是? 因为 <code>DB</code> 类的实现是基于 RAII 的, 在 delete 时触发析构方法自动进行清理工作.</p>
<h2><span id="数据库读写">数据库读写</span></h2><p>数据库提供了 <code>Put</code>、<code>Delete</code> 以及 <code>Get</code> 方法来修改、查询数据库. 下面的代码展示了将 key1 对应的 value 移动(先拷贝后删除)到 key2 下. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> value;</span><br><span class="line">leveldb::Status s = db-&gt;Get(leveldb::ReadOptions(), key1, &amp;value);</span><br><span class="line"><span class="keyword">if</span> (s.ok()) s = db-&gt;Put(leveldb::WriteOptions(), key2, value);</span><br><span class="line"><span class="keyword">if</span> (s.ok()) s = db-&gt;Delete(leveldb::WriteOptions(), key1);</span><br></pre></td></tr></table></figure>

<h2><span id="原子更新">原子更新</span></h2><p>注意, 上一小节中如果进程在 Put 了 key2 之后但是删除 key1 之前挂了, 那么同样的 value 就出现在了多个 keys 之下. 该问题可以通过使用 <code>WriteBatch</code> 类原子地应用一组操作来避免. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;leveldb/write_batch.h&quot;</span></span></span><br><span class="line">...</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> value;</span><br><span class="line">leveldb::Status s = db-&gt;Get(leveldb::ReadOptions(), key1, &amp;value);</span><br><span class="line"><span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">  leveldb::WriteBatch batch;</span><br><span class="line">  batch.Delete(key1);</span><br><span class="line">  batch.Put(key2, value);</span><br><span class="line">  s = db-&gt;Write(leveldb::WriteOptions(), &amp;batch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>WriteBatch</code> 保存着一系列将被应用到数据库的编辑操作, 这些操作会按照添加的顺序依次被执行. 注意, 我们先执行 Delete 后执行 Put, 这样如果 key1 和 key2 一样的情况下我们也不会错误地丢失数据. </p>
<p>除了原子性, <code>WriteBatch</code> 也能加速更新过程, 因为可以把一大批独立的操作添加到同一个 batch 中然后一次性执行. </p>
<h2><span id="同步写操作">同步写操作</span></h2><p>默认地, leveldb 每个写操作都是异步的: 进程把要写的内容 push 给操作系统后立马返回. 从操作系统内存到底层持久性存储的迁移异步地发生. 当然, 也可以把某个写操作的 sync 标识打开, 以等到数据真正被记录到持久化存储再让写操作返回. (在 Posix 系统上, 这是通过在写操作返回前调用 <code>fsync(...)</code> 或 <code>fdatasync(...)</code> 或 <code>msync(..., MS_SYNC)</code> 来实现的. )</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">leveldb::WriteOptions write_options;</span><br><span class="line">write_options.sync = <span class="literal">true</span>;</span><br><span class="line">db-&gt;Put(write_options, ...);</span><br></pre></td></tr></table></figure>

<p>异步写通常比同步写快 1000 倍. 异步写的缺点是, 一旦机器崩溃可能会导致最后几个更新操作丢失. 注意, 仅仅是写进程崩溃(而非机器重启)则不会引起任何更新操作丢失, 因为哪怕 sync 标识为 false, 在进程退出之前写操作也已经从进程内存 push 到了操作系统. </p>
<p>异步写总是可以安全使用. 比如你要将大量的数据写入数据库, 如果丢失了最后几个更新操作, 你可以重启整个写过程. 如果数据量非常大, 一个优化点是, 每进行 N 个异步写操作则进行一次同步地写操作, 如果期间发生了崩溃, 重启自从上一个成功的同步写操作以来的更新操作即可. (同步的写操作可以同时更新一个标识, 该标识用于描述崩溃重启后从何处开始重启更新操作. )</p>
<p><code>WriteBatch</code> 可以作为异步写操作的替代品. 多个更新操作可以放到同一个 WriteBatch 中然后通过一次同步写(即 <code>write_options.sync</code> 置为 true)一起应用. </p>
<h2><span id="并发">并发</span></h2><p>一个数据库同时只能被一个进程打开. LevelDB 会从操作系统获取一把锁来防止多进程同时打开同一个数据库. 在单个进程中, 同一个 <code>leveldb::DB</code> 对象可以被多个并发的线程安全地使用, 也就是说, 不同的线程可以写入或者获取迭代器, 或者针对同一个数据库调用 <code>Get</code>, 前述全部操作均不需要借助外部同步设施(leveldb 实现会自动地确保必要的同步). 但是其它对象, 比如 <code>Iterator</code> 或者 <code>WriteBatch</code> 需要外部自己提供同步保证. 如果两个线程共享此类对象, 需要使用锁进行互斥访问. 具体见对应的头文件. </p>
<h2><span id="迭代数据库">迭代数据库</span></h2><p>下面的用例展示了如何打印数据库中全部的 (key, value) 对. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">leveldb::Iterator* it = db-&gt;NewIterator(leveldb::ReadOptions());</span><br><span class="line"><span class="keyword">for</span> (it-&gt;SeekToFirst(); it-&gt;Valid(); it-&gt;Next()) &#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; it-&gt;key().ToString() &lt;&lt; <span class="string">&quot;: &quot;</span>  &lt;&lt; it-&gt;value().ToString() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">assert(it-&gt;status().ok());  <span class="comment">// Check for any errors found during the scan</span></span><br><span class="line"><span class="keyword">delete</span> it;</span><br></pre></td></tr></table></figure>

<p>下面的用例展示了如何打印 <code>[start, limit)</code> 范围内数据:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (it-&gt;Seek(start);</span><br><span class="line">   it-&gt;Valid() &amp;&amp; it-&gt;key().ToString() &lt; limit;</span><br><span class="line">   it-&gt;Next()) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然你也可以反向遍历(注意, 反向遍历可能比正向遍历要慢一些, 具体见前面的读性能基准测试). </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (it-&gt;SeekToLast(); it-&gt;Valid(); it-&gt;Prev()) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="快照">快照</span></h2><p>快照提供了针对整个 KV 存储的一致性只读视图. <code>ReadOptions::snapshot</code> 不为空表示读操作应该作用在 DB 的某个特定版本上; 若为空, 则读操作将会作用在当前版本的一个隐式的快照上.  </p>
<p>快照通过调用 <code>DB::GetSnapshot()</code> 方法创建:  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">leveldb::ReadOptions options;</span><br><span class="line">options.snapshot = db-&gt;GetSnapshot();</span><br><span class="line">... apply some updates to db ...</span><br><span class="line"><span class="comment">// 获取与前面快照对应的数据库迭代器</span></span><br><span class="line">leveldb::Iterator* iter = db-&gt;NewIterator(options);</span><br><span class="line">... read <span class="keyword">using</span> iter to view the state when the snapshot was created ...</span><br><span class="line"><span class="keyword">delete</span> iter;</span><br><span class="line">db-&gt;ReleaseSnapshot(options.snapshot);</span><br></pre></td></tr></table></figure>

<p>注意, 当一个快照不再使用的时候, 应该通过 <code>DB::ReleaseSnapshot</code> 接口进行释放. </p>
<h2><span id="slice-切片">Slice 切片</span></h2><p><code>it-&gt;key()</code> 和 <code>it-&gt;value()</code> 调用返回的值是 <code>leveldb::Slice</code> 类型的实例. 熟悉 Golang 或者 Rust 的同学对 slice 应该不陌生. slice 是一个简单的数据结构, 包含一个长度和一个指向外部字节数组的指针. 返回一个切片比返回 <code>std::string</code> 更加高效, 因为不需要隐式地拷贝大量的 keys 和 values. 另外, leveldb 方法不返回空字符结尾的 C 风格地字符串, 因为 leveldb 的 keys 和 values 允许包含 <code>\0</code> 字节. </p>
<p>C++ 风格的 string 和 C 风格的空字符结尾的字符串很容易转换为一个切片: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">leveldb::Slice s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">str</span><span class="params">(<span class="string">&quot;world&quot;</span>)</span></span>;</span><br><span class="line">leveldb::Slice s2 = str;</span><br></pre></td></tr></table></figure>

<p>一个切片也很容易转换回 C++ 风格的字符串: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str = s1.ToString();</span><br><span class="line">assert(str == <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>注意, 当使用切片时, 调用者要确保它内部指针指向的外部字节数组保持存活. 比如, 下面的代码就有问题: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">leveldb::Slice slice;</span><br><span class="line"><span class="keyword">if</span> (...) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> str = ...;</span><br><span class="line">  slice = str;</span><br><span class="line">&#125;</span><br><span class="line">Use(slice);</span><br></pre></td></tr></table></figure>

<p>当 if 语句结束的时候, str 将会被销毁, 切片的底层存储也随之消失了, 后面再用就出问题了. </p>
<h2><span id="比较器">比较器</span></h2><p>前面的例子中用的都是默认的比较函数, 即逐字节按照字典序比较. 你可以定制自己的比较函数, 然后在打开数据库的时候传入. 只需继承 <code>leveldb::Comparator</code> 然后定义相关逻辑即可, 下面是一个例子: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoPartComparator</span> :</span> <span class="keyword">public</span> leveldb::Comparator &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Three-way comparison function:</span></span><br><span class="line">  <span class="comment">//   if a &lt; b: negative result</span></span><br><span class="line">  <span class="comment">//   if a &gt; b: positive result</span></span><br><span class="line">  <span class="comment">//   else: zero result</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">Compare</span><span class="params">(<span class="keyword">const</span> leveldb::Slice&amp; a, <span class="keyword">const</span> leveldb::Slice&amp; b)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a1, a2, b1, b2;</span><br><span class="line">    ParseKey(a, &amp;a1, &amp;a2);</span><br><span class="line">    ParseKey(b, &amp;b1, &amp;b2);</span><br><span class="line">    <span class="keyword">if</span> (a1 &lt; b1) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (a1 &gt; b1) <span class="keyword">return</span> +<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (a2 &lt; b2) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (a2 &gt; b2) <span class="keyword">return</span> +<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Ignore the following methods for now:</span></span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">Name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;TwoPartComparator&quot;</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">FindShortestSeparator</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>*, <span class="keyword">const</span> leveldb::Slice&amp;)</span> <span class="keyword">const</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">FindShortSuccessor</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>*)</span> <span class="keyword">const</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后使用上面定义的比较器打开数据库: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例化比较器</span></span><br><span class="line">TwoPartComparator cmp;</span><br><span class="line">leveldb::DB* db;</span><br><span class="line">leveldb::Options options;</span><br><span class="line">options.create_if_missing = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 将比较器赋值给 options.comparator</span></span><br><span class="line">options.comparator = &amp;cmp;</span><br><span class="line"><span class="comment">// 打开数据库</span></span><br><span class="line">leveldb::Status status = leveldb::DB::Open(options, <span class="string">&quot;/tmp/testdb&quot;</span>, &amp;db);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3><span id="后向兼容性">后向兼容性</span></h3><p>比较器 <code>Name</code> 方法返回的结果在创建数据库时会被绑定到数据库上, 后续每次打开都会进行检查. 如果名称改了, 对 <code>leveldb::DB::Open</code> 的调用就会失败. 因此, 当且仅当在新的 key 格式和比较函数与已有的数据库不兼容而且已有数据不再被需要的时候再修改比较器名称. 总而言之, 一个数据库只能对应一个比较器, 而且比较器由名字唯一确定, 一旦修改名称或者比较器逻辑, 数据库的操作逻辑就统统会出错, 毕竟 leveldb 是一个有序的 KV 存储.</p>
<p>如果非要修改比较逻辑怎么办呢? 你可以根据预先规划一点一点的演进你的 key 格式, 注意, 事先的演进规划非常重要. 比如, 你可以存储一个版本号在每个 key 的结尾(大多数场景, 一个字节足够了). 当你想要切换到新的 key 格式的时候(比如新增 third-part 到上面例子 <code>TwoPartComparator</code> 处理的 keys 中), 那么你需要做的是:</p>
<ul>
<li>(a) 保持比较器名称不变</li>
<li>(b) 递增新 keys 的版本号</li>
<li>(c) 修改比较器函数以让其使用版本号来决定如何进行排序. </li>
</ul>
<h2><span id="性能调优">性能调优</span></h2><p>通过修改 <code>include/leveldb/options.h</code> 中定义的类型的默认值来对 leveldb 的性能进行调优. </p>
<h3><span id="block-大小">Block 大小</span></h3><p>Leveldb 把相邻的 keys 组织在同一个 block 中(具体见后面文章针对 sorted table 文件格式的描述), 而且 block 是 leveldb 把数据从内存到转移到持久化存储和从持久化存储转移到内存的基本单位. 默认的, 压缩前 block 大约为 4KB. 经常处理大块数据的应用可能希望把这个值调大, 而针对数据做”点读” 的应用可能希望这个值小一点, 这样性能可能会更高一些. 但是, 没有证据表明该值小于 1KB 或者大于几个 MB 的时候性能会表现更好. 同时要注意, 针对大的 block size, 压缩效率会更高一些. </p>
<h3><span id="压缩">压缩</span></h3><p>每个 block 在写入持久存储之前都会被单独压缩. 压缩默认是开启的, 因为默认的压缩算法非常快, 而且对于不可压缩的数据会自动关闭压缩功能. 极少有场景会让用户想要完全关闭压缩功能, 除非基准测试显示关闭压缩会显著改善性能. 按照下面方式做就关闭了压缩功能: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">leveldb::Options options;</span><br><span class="line">options.compression = leveldb::kNoCompression;</span><br><span class="line">... leveldb::DB::Open(options, name, ...) ....</span><br></pre></td></tr></table></figure>

<h3><span id="缓存">缓存</span></h3><p>数据库的内容存储在文件系统的一组文件里, 每个文件保存着一系列压缩后的 blocks. 如果 <code>options.block_cache</code> 不为空, 它就会被用于缓存频繁被使用的 block 内容(已解压缩). </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;leveldb/cache.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">leveldb::Options options;</span><br><span class="line"><span class="comment">// 打开数据库之前分配一个 100MB 的 LRU Cache 用于缓存解压的 blocks</span></span><br><span class="line">options.block_cache = leveldb::NewLRUCache(<span class="number">100</span> * <span class="number">1048576</span>);  <span class="comment">// 100MB cache</span></span><br><span class="line">leveldb::DB* db;</span><br><span class="line"><span class="comment">// 打开数据库</span></span><br><span class="line">leveldb::DB::Open(options, name, &amp;db);</span><br><span class="line">... use the db ...</span><br><span class="line"><span class="keyword">delete</span> db</span><br><span class="line"><span class="keyword">delete</span> options.block_cache;</span><br></pre></td></tr></table></figure>

<p>注意 cache 保存的是未压缩的数据, 因此应该根据应用程序所需的数据大小来设置它的大小. (已压缩数据的缓存工作交给操作系统的 buffer cache 或者用户提供的定制的 Env 实现去干. )</p>
<p>当执行一个大块数据读操作时, 应用程序可能想要取消缓存功能, 这样读进来的大块数据就不会导致 cache 中当前大部分数据被置换出去, 我们可以为它提供一个单独的 iterator 来达到该目的: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">leveldb::ReadOptions options;</span><br><span class="line"><span class="comment">// 缓存设置为关闭</span></span><br><span class="line">options.fill_cache = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 用该设置去创建一个新的迭代器</span></span><br><span class="line">leveldb::Iterator* it = db-&gt;NewIterator(options);</span><br><span class="line"><span class="comment">// 用该迭代器去处理大块数据</span></span><br><span class="line"><span class="keyword">for</span> (it-&gt;SeekToFirst(); it-&gt;Valid(); it-&gt;Next()) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="key-的布局设计">Key 的布局设计</span></h3><p>注意, 磁盘传输的单位以及磁盘缓存的单位都是一个 block. 相邻的 keys(已排序)总是在同一个 block 中. 因此应用程序可以通过把需要一起访问的 keys 放在一起, 同时把不经常使用的 keys 放到一个独立的键空间区域来提升性能. </p>
<p>举个例子, 假设我们正基于 leveldb 实现一个简单的文件系统. 我们打算存储到这个文件系统的数据项类型如下: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">filename -&gt; permission-bits, length, list of file_block_ids</span><br><span class="line">file_block_id -&gt; data</span><br></pre></td></tr></table></figure>

<p>我们可以给上面表示 <code>filename</code> 的 key 增加一个字符前缀, 比如 ‘/‘, 然后给表示 <code>file_block_id</code> 的 key 增加另一个不同的前缀, 比如 ‘0’, 这样这些不同用途的 key 就具有了各自独立的键空间区域, 扫描元数据的时候我们就不用读取和缓存大块文件内容数据了. </p>
<h3><span id="过滤器">过滤器</span></h3><p>鉴于 leveldb 数据在磁盘上的组织形式, 一次 <code>Get()</code> 调用可能涉及多次磁盘读操作. 可配置的 FilterPolicy 机制可以用来大幅减少磁盘读次数. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">leveldb::Options options;</span><br><span class="line"><span class="comment">// 设置启用基于布隆过滤器的过滤策略</span></span><br><span class="line">options.filter_policy = NewBloomFilterPolicy(<span class="number">10</span>);</span><br><span class="line">leveldb::DB* db;</span><br><span class="line"><span class="comment">// 用该设置打开数据库</span></span><br><span class="line">leveldb::DB::Open(options, <span class="string">&quot;/tmp/testdb&quot;</span>, &amp;db);</span><br><span class="line">... use the database ...</span><br><span class="line"><span class="keyword">delete</span> db;</span><br><span class="line"><span class="keyword">delete</span> options.filter_policy;</span><br></pre></td></tr></table></figure>

<p>上述代码将一个基于布隆过滤器的过滤策略与数据库进行了关联. 基于布隆过滤器的过滤方式依赖于如下事实, 在内存中保存每个 key 的部分位(在上面例子中是 10 位, 因为我们传给 <code>NewBloomFilterPolicy</code> 的参数是 10). 这个过滤器将会使得 <code>Get()</code> 调用中非必须的磁盘读操作大约减少 100 倍. 每个 key 用于过滤器的位数增加将会进一步减少读磁盘次数, 当然也会占用更多内存空间. 我们推荐数据集无法全部放入内存同时又存在大量随机读的应用设置一个过滤器策略. </p>
<p>如果你在使用定制的比较器, 你应该确保你在用的过滤器策略与你的比较器兼容. 举个例子, 如果一个比较器在比较 key 的时候忽略结尾的空格, 那么<code>NewBloomFilterPolicy</code> 一定不能与此比较器共存. 相反, 应用应该提供一个定制的过滤器策略, 而且它也应该忽略键的尾部空格. 示例如下: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomFilterPolicy</span> :</span> <span class="keyword">public</span> leveldb::FilterPolicy &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  FilterPolicy* builtin_policy_;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  CustomFilterPolicy() : builtin_policy_(NewBloomFilterPolicy(<span class="number">10</span>)) &#123;&#125;</span><br><span class="line">  ~CustomFilterPolicy() &#123; <span class="keyword">delete</span> builtin_policy_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">Name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;IgnoreTrailingSpacesFilter&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">CreateFilter</span><span class="params">(<span class="keyword">const</span> Slice* keys, <span class="keyword">int</span> n, <span class="built_in">std</span>::<span class="built_in">string</span>* dst)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Use builtin bloom filter code after removing trailing spaces</span></span><br><span class="line">    <span class="comment">// 将尾部空格移除后再使用内置的布隆过滤器</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Slice&gt; <span class="title">trimmed</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      trimmed[i] = RemoveTrailingSpaces(keys[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> builtin_policy_-&gt;CreateFilter(&amp;trimmed[i], n, dst);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然也可以自己提供非基于布隆过滤器的过滤器策略, 具体见 <code>leveldb/filter_policy.h</code>. </p>
<h2><span id="校验和">校验和</span></h2><p>Leveldb 将一个校验和与它存储在文件系统中的全部数据进行关联. 根据激进程度有两种方式控制校验和的核对: </p>
<p><code>ReadOptions::verify_checksums</code> 可以设置为 true 来强制核对从文件系统读取的全部数据的进行校验和检查. 默认为 false. </p>
<p><code>Options::paranoid_checks</code> 在数据库打开之前设置为 true 可以使得数据库一旦检测到数据损毁即报错. 取决于数据库损坏部位, 报错时机可能是打开数据库后的时候, 也可能是在后续执行某个操作的时候. 该配置默认是关闭状态, 这样即使持久性存储部分虽坏数据库也能继续使用. </p>
<p>如果数据库损坏了(当开启 <code>Options::paranoid_checks</code> 的时候可能就打不开了), <code>leveldb::RepairDB</code> 函数可以用于对尽可能多的数据进行修复. </p>
<h2><span id="近似空间大小">近似空间大小</span></h2><p><code>GetApproximateSizes</code> 方法用于获取一个或多个键区间占据的文件系统近似大小(单位, 字节). </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">leveldb::Range ranges[<span class="number">2</span>];</span><br><span class="line">ranges[<span class="number">0</span>] = leveldb::Range(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">ranges[<span class="number">1</span>] = leveldb::Range(<span class="string">&quot;x&quot;</span>, <span class="string">&quot;z&quot;</span>);</span><br><span class="line"><span class="keyword">uint64_t</span> sizes[<span class="number">2</span>];</span><br><span class="line">leveldb::Status s = db-&gt;GetApproximateSizes(ranges, <span class="number">2</span>, sizes);</span><br></pre></td></tr></table></figure>

<p>上述代码结果是, <code>size[0]</code> 保存 <code>[a..c)</code> 键区间对应的文件系统大致字节数, <code>size[1]</code> 保存 <code>[x..z)</code> 键区间对应的文件系统大致字节数. </p>
<h2><span id="环境变量">环境变量</span></h2><p>由 leveldb 发起的全部文件操作以及其它的操作系统调用最后都会被路由给一个 <code>leveldb::Env</code> 对象. 用户也可以提供自己的 <code>Env</code> 实现以达到更好的控制. 比如, 如果应用程序想要针对 leveldb 的文件 IO 引入一个人工延迟以限制 leveldb 对同一个系统中其它应用的影响:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定制自己的 Env </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SlowEnv</span> :</span> <span class="keyword">public</span> leveldb::Env &#123;</span><br><span class="line">  ... implementation of the Env interface ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SlowEnv env;</span><br><span class="line">leveldb::Options options;</span><br><span class="line"><span class="comment">// 用定制的 Env 打开数据库</span></span><br><span class="line">options.env = &amp;env;</span><br><span class="line">Status s = leveldb::DB::Open(options, ...);</span><br></pre></td></tr></table></figure>

<h2><span id="移植性">移植性</span></h2><p>如果某个特定平台提供 <code>leveldb/port/port.h</code> 导出的类型/方法/函数实现, 那么 leveldb 可以被移植到该平台上, 更多细节见 <code>leveldb/port/port_example.h</code>. </p>
<p>另外, 新平台可能还需要一个新的默认的 <code>leveldb::Env</code> 实现. 具体可参考 <code>leveldb/util/env_posix.h</code> 实现. </p>
<p>–End–</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://chielungcheung.github.io/2020/09/10/hello-world-again/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chienlung Cheung">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="programatrix">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/10/hello-world-again/" class="post-title-link" itemprop="url">Hello World, Again</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-10 20:14:15" itemprop="dateCreated datePublished" datetime="2020-09-10T20:14:15+00:00">2020-09-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-25 06:37:30" itemprop="dateModified" datetime="2020-09-25T06:37:30+00:00">2020-09-25</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2020/09/10/hello-world-again/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/09/10/hello-world-again/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>之前的博客采用 OctoPress 搭建, 但是当时同步数据没有把 _post 下面的 md 原始文件同步, 导致这次迁移没法把之前几年积攒的文章搬过来.</p>
<p>Hello world, again!</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Chienlung Cheung</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chienlung Cheung</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  













<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://Chienlung.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>

</body>
</html>
